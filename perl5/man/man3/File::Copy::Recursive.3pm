.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "inc::File::Copy::Recursive 3"
.TH inc::File::Copy::Recursive 3 "2012-11-01" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
File::Copy::Recursive \- Perl extension for recursively copying files and directories
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
.Ve
.PP
.Vb 3
\&  fcopy($orig,$new[,$buf]) or die $!;
\&  rcopy($orig,$new[,$buf]) or die $!;
\&  dircopy($orig,$new[,$buf]) or die $!;
.Ve
.PP
.Vb 3
\&  fmove($orig,$new[,$buf]) or die $!;
\&  rmove($orig,$new[,$buf]) or die $!;
\&  dirmove($orig,$new[,$buf]) or die $!;
.Ve
.PP
.Vb 2
\&  rcopy_glob("orig/stuff-*", $trg [, $buf]) or die $!;
\&  rmove_glob("orig/stuff-*", $trg [,$buf]) or die $!;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module copies and moves directories recursively (or single files, well... singley) to an optional depth and attempts to preserve each file or directory's mode.
.SH "EXPORT"
.IX Header "EXPORT"
None by default. But you can export all the functions as in the example above and the path* functions if you wish.
.Sh "\fIfcopy()\fP"
.IX Subsection "fcopy()"
This function uses File::Copy's \fIcopy()\fR function to copy a file but not a directory. Any directories are recursively created if need be.
One difference to \fIFile::Copy::copy()\fR is that fcopy attempts to preserve the mode (see Preserving Mode below)
The optional \f(CW$buf\fR in the synopsis if the same as \fIFile::Copy::copy()\fR's 3rd argument
returns the same as \fIFile::Copy::copy()\fR in scalar context and 1,0,0 in list context to accomidate \fIrcopy()\fR's list context on regular files. (See below for more info)
.Sh "\fIdircopy()\fP"
.IX Subsection "dircopy()"
This function recursively traverses the \f(CW$orig\fR directory's structure and recursively copies it to the \f(CW$new\fR directory.
\&\f(CW$new\fR is created if necessary (multiple non existant directories is ok (\s-1IE\s0 foo/bar/baz). The script logically and portably creates all of them if necessary).
It attempts to preserve the mode (see Preserving Mode below) and 
by default it copies all the way down into the directory, (see Managing Depth) below.
If a directory is not specified it croaks just like fcopy croaks if its not a file that is specified.
.PP
returns true or false, for true in scalar context it returns the number of files and directories copied,
In list context it returns the number of files and directories, number of directories only, depth level traversed.
.PP
.Vb 2
\&  my $num_of_files_and_dirs = dircopy($orig,$new);
\&  my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = dircopy($orig,$new);
.Ve
.PP
Normally it stops and return's if a copy fails, to continue on regardless set \f(CW$File::Copy::Recursive::SkipFlop\fR to true.
.PP
.Vb 1
\&    local $File::Copy::Recursive::SkipFlop = 1;
.Ve
.PP
That way it will copy everythgingit can ina directory and won't stop because of permissions, etc...
.Sh "\fIrcopy()\fP"
.IX Subsection "rcopy()"
This function will allow you to specify a file *or* directory. It calls \fIfcopy()\fR if its a file and \fIdircopy()\fR if its a directory.
If you call \fIrcopy()\fR (or \fIfcopy()\fR for that matter) on a file in list context, the values will be 1,0,0 since no directories and no depth are used. 
This is important becasue if its a directory in list context and there is only the initial directory the return value is 1,1,1.
.Sh "\fIrcopy_glob()\fP"
.IX Subsection "rcopy_glob()"
This function lets you specify a pattern suitable for perl's \fIglob()\fR as the first argument. Subsequently each path returned by perl's \fIglob()\fR gets \fIrcopy()\fRied.
.PP
It returns and array whose items are array refs that contain the return value of each \fIrcopy()\fR call.
.PP
It forces behavior as if \f(CW$File::Copy::Recursive::CPRFComp\fR is true.
.Sh "\fIfmove()\fP"
.IX Subsection "fmove()"
Copies the file then removes the original. You can manage the path the original file is in according to \f(CW$RemvBase\fR.
.Sh "\fIdirmove()\fP"
.IX Subsection "dirmove()"
Uses \fIdircopy()\fR to copy the directory then removes the original. You can manage the path the original directory is in according to \f(CW$RemvBase\fR.
.Sh "\fIrmove()\fP"
.IX Subsection "rmove()"
Like \fIrcopy()\fR but calls \fIfmove()\fR or \fIdirmove()\fR instead.
.Sh "\fIrmove_glob()\fP"
.IX Subsection "rmove_glob()"
Like \fIrcopy_glob()\fR but calls \fIrmove()\fR instead of \fIrcopy()\fR
.PP
\fI$RemvBase\fR
.IX Subsection "$RemvBase"
.PP
Default is false. When set to true the *\fImove()\fR functions will not only attempt to remove the original file or directory but will remove the given path it is in.
.PP
So if you:
.PP
.Vb 2
\&   rmove('foo/bar/baz', '/etc/');
\&   # "baz" is removed from foo/bar after it is successfully copied to /etc/
.Ve
.PP
.Vb 5
\&   local $File::Copy::Recursive::Remvbase = 1;
\&   rmove('foo/bar/baz','/etc/');
\&   # if baz is successfully copied to /etc/ :
\&   # first "baz" is removed from foo/bar
\&   # then "foo/bar is removed via pathrm()
.Ve
.PP
$ForcePth
.IX Subsection "$ForcePth"
.PP
Default is false. When set to true it calls \fIpathempty()\fR before any directories are removed to empty the directory so it can be \fIrmdir()\fR'ed when \f(CW$RemvBase\fR is in effect.
.Sh "Creating and Removing Paths"
.IX Subsection "Creating and Removing Paths"
\fI$NoFtlPth\fR
.IX Subsection "$NoFtlPth"
.PP
Default is false. If set to true  \fIrmdir()\fR, \fImkdir()\fR, and \fIpathempty()\fR calls in \fIpathrm()\fR and \fIpathmk()\fR do not \fIreturn()\fR on failure.
.PP
If its set to true they just silently go about their business regardless. This isn't a good idea but its there if you want it.
.PP
\fI$DirPerms\fR
.IX Subsection "$DirPerms"
.PP
Mode to pass to any \fImkdir()\fR calls. Defaults to 0777 as per \fIumask()\fR's \s-1POD\s0. Explicitly having this allows older perls to be able to use \s-1FCR\s0 and might add a bit of flexibility for you.
.PP
Any value you set it to should be suitable for \fIoct()\fR
.PP
\fIPath functions\fR
.IX Subsection "Path functions"
.PP
These functions exist soley because they were necessary for the move and copy functions to have the features they do and not because they are of themselves the purpose of this module. That being said, here is how they work so you can understand how the copy and move funtions work and use them by themselves if you wish.
.PP
\fIpathrm()\fR
.IX Subsection "pathrm()"
.PP
Removes a given path recursively. It removes the *entire* path so be carefull!!!
.PP
Returns 2 if the given path is not a directory.
.PP
.Vb 2
\&  File::Copy::Recursive::pathrm('foo/bar/baz') or die $!;
\&  # foo no longer exists
.Ve
.PP
Same as:
.PP
.Vb 3
\&  rmdir 'foo/bar/baz' or die $!;
\&  rmdir 'foo/bar' or die $!;
\&  rmdir 'foo' or die $!;
.Ve
.PP
An optional second argument makes it call \fIpathempty()\fR before any \fIrmdir()\fR's when set to true.
.PP
.Vb 2
\&  File::Copy::Recursive::pathrm('foo/bar/baz', 1) or die $!;
\&  # foo no longer exists
.Ve
.PP
Same as:PFSCheck
.PP
.Vb 6
\&  File::Copy::Recursive::pathempty('foo/bar/baz') or die $!;
\&  rmdir 'foo/bar/baz' or die $!;
\&  File::Copy::Recursive::pathempty('foo/bar/') or die $!;
\&  rmdir 'foo/bar' or die $!;
\&  File::Copy::Recursive::pathempty('foo/') or die $!;
\&  rmdir 'foo' or die $!;
.Ve
.PP
An optional third argument acts like \f(CW$File::Copy::Recursive::NoFtlPth\fR, again probably not a good idea.
.PP
\fIpathempty()\fR
.IX Subsection "pathempty()"
.PP
Recursively removes the given directory's contents so it is empty. returns 2 if argument is not a directory, 1 on successfully emptying the directory.
.PP
.Vb 2
\&   File::Copy::Recursive::pathempty($pth) or die $!;
\&   # $pth is now an empty directory
.Ve
.PP
\fIpathmk()\fR
.IX Subsection "pathmk()"
.PP
Creates a given path recursively. Creates foo/bar/baz even if foo does not exist.
.PP
.Vb 1
\&   File::Copy::Recursive::pathmk('foo/bar/baz') or die $!;
.Ve
.PP
An optional second argument if true acts just like \f(CW$File::Copy::Recursive::NoFtlPth\fR, which means you'd never get your \fIdie()\fR if something went wrong. Again, probably a *bad* idea.
.PP
\fIpathrmdir()\fR
.IX Subsection "pathrmdir()"
.PP
Same as \fIrmdir()\fR but it calls \fIpathempty()\fR first to recursively empty it first since rmdir can not remove a directory with contents.
Just removes the top directory the path given instead of the entire path like \fIpathrm()\fR. Return 2 if given argument does not exist (\s-1IE\s0 its already gone). Return false if it exists but is not a directory.
.Sh "Preserving Mode"
.IX Subsection "Preserving Mode"
By default a quiet attempt is made to change the new file or directory to the mode of the old one.
To turn this behavior off set
  \f(CW$File::Copy::Recursive::KeepMode\fR
to false;
.Sh "Managing Depth"
.IX Subsection "Managing Depth"
You can set the maximum depth a directory structure is recursed by setting:
  \f(CW$File::Copy::Recursive::MaxDepth\fR 
to a whole number greater than 0.
.Sh "SymLinks"
.IX Subsection "SymLinks"
If your system supports symlinks then symlinks will be copied as symlinks instead of as the target file.
Perl's \fIsymlink()\fR is used instead of File::Copy's \fIcopy()\fR
You can customize this behavior by setting \f(CW$File::Copy::Recursive::CopyLink\fR to a true or false value.
It is already set to true or false dending on your system's support of symlinks so you can check it with an if statement to see how it will behave:
.PP
.Vb 5
\&    if($File::Copy::Recursive::CopyLink) {
\&        print "Symlinks will be preserved\en";
\&    } else {
\&        print "Symlinks will not be preserved because your system does not support it\en";
\&    }
.Ve
.PP
If symlinks are being copied you can set \f(CW$File::Copy::Recursive::BdTrgWrn\fR to true to make it carp when it copies a link whose target does not exist. Its false by default.
.PP
.Vb 1
\&    local $File::Copy::Recursive::BdTrgWrn  = 1;
.Ve
.Sh "Removing existing target file or directory before copying."
.IX Subsection "Removing existing target file or directory before copying."
This can be done by setting \f(CW$File::Copy::Recursive::RMTrgFil\fR or \f(CW$File::Copy::Recursive::RMTrgDir\fR for file or directory behavior respectively.
.PP
0 = off (This is the default)
.PP
1 = \fIcarp()\fR $! if removal fails
.PP
2 = return if removal fails
.PP
.Vb 3
\&    local $File::Copy::Recursive::RMTrgFil = 1;
\&    fcopy($orig, $target) or die $!;
\&    # if it fails it does warn() and keeps going
.Ve
.PP
.Vb 3
\&    local $File::Copy::Recursive::RMTrgDir = 2;
\&    dircopy($orig, $target) or die $!;
\&    # if it fails it does your "or die"
.Ve
.PP
This should be unnecessary most of the time but its there if you need it :)
.Sh "Turning off \fIstat()\fP check"
.IX Subsection "Turning off stat() check"
By default the files or directories are checked to see if they are the same (\s-1IE\s0 linked, or two paths (absolute/relative or different relative paths) to the same file) by comparing the file's \fIstat()\fR info. 
It's a very efficient check that croaks if they are and shouldn't be turned off but if you must for some weird reason just set \f(CW$File::Copy::Recursive::PFSCheck\fR to a false value. (\*(L"\s-1PFS\s0\*(R" stands for \*(L"Physical File System\*(R")
.Sh "Emulating cp \-rf dir1/ dir2/"
.IX Subsection "Emulating cp -rf dir1/ dir2/"
By default dircopy($dir1,$dir2) will put \f(CW$dir1\fR's contents right into \f(CW$dir2\fR whether \f(CW$dir2\fR exists or not.
.PP
You can make \fIdircopy()\fR emulate cp \-rf by setting \f(CW$File::Copy::Recursive::CPRFComp\fR to true.
.PP
\&\s-1NOTE:\s0 This only emulates \-f in the sense that it does not prompt. It does not remove the target file or directory if it exists.
If you need to do that then use the variables \f(CW$RMTrgFil\fR and \f(CW$RMTrgDir\fR described in \*(L"Removing existing target file or directory before copying\*(R" above.
.PP
That means that if \f(CW$dir2\fR exists it puts the contents into \f(CW$dir2\fR/$dir1 instead of \f(CW$dir2\fR just like cp \-rf.
If \f(CW$dir2\fR does not exist then the contents go into \f(CW$dir2\fR like normal (also like cp \-rf)
.PP
So assuming 'foo/file':
.PP
.Vb 3
\&    dircopy('foo', 'bar') or die $!;
\&    # if bar does not exist the result is bar/file
\&    # if bar does exist the result is bar/file
.Ve
.PP
.Vb 4
\&    $File::Copy::Recursive::CPRFComp = 1;
\&    dircopy('foo', 'bar') or die $!;
\&    # if bar does not exist the result is bar/file
\&    # if bar does exist the result is bar/foo/file
.Ve
.PP
You can also specify a star for cp \-rf glob type behavior:
.PP
.Vb 3
\&    dircopy('foo/*', 'bar') or die $!;
\&    # if bar does not exist the result is bar/file
\&    # if bar does exist the result is bar/file
.Ve
.PP
.Vb 4
\&    $File::Copy::Recursive::CPRFComp = 1;
\&    dircopy('foo/*', 'bar') or die $!;
\&    # if bar does not exist the result is bar/file
\&    # if bar does exist the result is bar/file
.Ve
.PP
\&\s-1NOTE:\s0 The '*' is only like cp \-rf foo/* and *DOES \s-1NOT\s0 \s-1EXPAND\s0 \s-1PARTIAL\s0 \s-1DIRECTORY\s0 \s-1NAMES\s0 \s-1LIKE\s0 \s-1YOUR\s0 \s-1SHELL\s0 DOES* (\s-1IE\s0 not like cp \-rf fo* to copy foo/*)
.Sh "Allowing Copy Loops"
.IX Subsection "Allowing Copy Loops"
If you want to allow:
.PP
.Vb 1
\&  cp -rf . foo/
.Ve
.PP
type behavior set \f(CW$File::Copy::Recursive::CopyLoop\fR to true.
.PP
This is false by default so that a check is done to see if the source directory will contain the target directory and croaks to avoid this problem.
.PP
If you ever find a situation where \f(CW$CopyLoop\fR = 1 is desirable let me know (\s-1IE\s0 its a bad bad idea but is there if you want it)
.PP
(Note: On Windows this was necessary since it uses \fIstat()\fR to detemine samedness and \fIstat()\fR is essencially useless for this on Windows. 
The test is now simply skipped on Windows but I'd rather have an actual reliable check if anyone in Microsoft land would care to share)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Copy File::Spec
.SH "TO DO"
.IX Header "TO DO"
I am currently working on and reviewing some other modules to use in the new interface so we can lose the horrid globals as well as some other undesirable traits and also more easily make available some long standing requests.
.PP
Tests will be easier to do with the new interface and hence the testing focus will shift to the new interface and aim to be comprehensive.
.PP
The old interface will work, it just won't be brought in until it is used, so it will add no overhead for users of the new interface.
.PP
I'll add this after the latest verision has been out for a while with no new features or issues found :)
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel Muey, <http://drmuey.com/cpan_contact.pl>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004 by Daniel Muey
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
