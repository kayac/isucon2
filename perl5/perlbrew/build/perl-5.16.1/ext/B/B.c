/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of B.xs. Do not edit this file, edit B.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "B.xs"
/*	B.xs
 *
 *	Copyright (c) 1996 Malcolm Beattie
 *
 *	You may distribute under the terms of either the GNU General Public
 *	License or the Artistic License, as specified in the README file.
 *
 */

#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#ifdef PerlIO
typedef PerlIO * InputStream;
#else
typedef FILE * InputStream;
#endif


static const char* const svclassnames[] = {
    "B::NULL",
#if PERL_VERSION >= 9
    "B::BIND",
#endif
    "B::IV",
    "B::NV",
#if PERL_VERSION <= 10
    "B::RV",
#endif
    "B::PV",
    "B::PVIV",
    "B::PVNV",
    "B::PVMG",
#if PERL_VERSION <= 8
    "B::BM",
#endif
#if PERL_VERSION >= 11
    "B::REGEXP",
#endif
#if PERL_VERSION >= 9
    "B::GV",
#endif
    "B::PVLV",
    "B::AV",
    "B::HV",
    "B::CV",
#if PERL_VERSION <= 8
    "B::GV",
#endif
    "B::FM",
    "B::IO",
};

typedef enum {
    OPc_NULL,	/* 0 */
    OPc_BASEOP,	/* 1 */
    OPc_UNOP,	/* 2 */
    OPc_BINOP,	/* 3 */
    OPc_LOGOP,	/* 4 */
    OPc_LISTOP,	/* 5 */
    OPc_PMOP,	/* 6 */
    OPc_SVOP,	/* 7 */
    OPc_PADOP,	/* 8 */
    OPc_PVOP,	/* 9 */
    OPc_LOOP,	/* 10 */
    OPc_COP	/* 11 */
} opclass;

static const char* const opclassnames[] = {
    "B::NULL",
    "B::OP",
    "B::UNOP",
    "B::BINOP",
    "B::LOGOP",
    "B::LISTOP",
    "B::PMOP",
    "B::SVOP",
    "B::PADOP",
    "B::PVOP",
    "B::LOOP",
    "B::COP"	
};

static const size_t opsizes[] = {
    0,	
    sizeof(OP),
    sizeof(UNOP),
    sizeof(BINOP),
    sizeof(LOGOP),
    sizeof(LISTOP),
    sizeof(PMOP),
    sizeof(SVOP),
    sizeof(PADOP),
    sizeof(PVOP),
    sizeof(LOOP),
    sizeof(COP)	
};

#define MY_CXT_KEY "B::_guts" XS_VERSION

typedef struct {
    int		x_walkoptree_debug;	/* Flag for walkoptree debug hook */
    SV *	x_specialsv_list[7];
} my_cxt_t;

START_MY_CXT

#define walkoptree_debug	(MY_CXT.x_walkoptree_debug)
#define specialsv_list		(MY_CXT.x_specialsv_list)

static opclass
cc_opclass(pTHX_ const OP *o)
{
    bool custom = 0;

    if (!o)
	return OPc_NULL;

    if (o->op_type == 0)
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    if (o->op_type == OP_SASSIGN)
	return ((o->op_private & OPpASSIGN_BACKWARDS) ? OPc_UNOP : OPc_BINOP);

    if (o->op_type == OP_AELEMFAST) {
#if PERL_VERSION <= 14
	if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
#endif
#ifdef USE_ITHREADS
	    return OPc_PADOP;
#else
	    return OPc_SVOP;
#endif
    }
    
#ifdef USE_ITHREADS
    if (o->op_type == OP_GV || o->op_type == OP_GVSV ||
	o->op_type == OP_RCATLINE)
	return OPc_PADOP;
#endif

    if (o->op_type == OP_CUSTOM)
        custom = 1;

    switch (OP_CLASS(o)) {
    case OA_BASEOP:
	return OPc_BASEOP;

    case OA_UNOP:
	return OPc_UNOP;

    case OA_BINOP:
	return OPc_BINOP;

    case OA_LOGOP:
	return OPc_LOGOP;

    case OA_LISTOP:
	return OPc_LISTOP;

    case OA_PMOP:
	return OPc_PMOP;

    case OA_SVOP:
	return OPc_SVOP;

    case OA_PADOP:
	return OPc_PADOP;

    case OA_PVOP_OR_SVOP:
        /*
         * Character translations (tr///) are usually a PVOP, keeping a 
         * pointer to a table of shorts used to look up translations.
         * Under utf8, however, a simple table isn't practical; instead,
         * the OP is an SVOP (or, under threads, a PADOP),
         * and the SV is a reference to a swash
         * (i.e., an RV pointing to an HV).
         */
	return (!custom &&
		   (o->op_private & (OPpTRANS_TO_UTF|OPpTRANS_FROM_UTF))
	       )
#if  defined(USE_ITHREADS) \
  && (PERL_VERSION > 8 || (PERL_VERSION == 8 && PERL_SUBVERSION >= 9))
		? OPc_PADOP : OPc_PVOP;
#else
		? OPc_SVOP : OPc_PVOP;
#endif

    case OA_LOOP:
	return OPc_LOOP;

    case OA_COP:
	return OPc_COP;

    case OA_BASEOP_OR_UNOP:
	/*
	 * UNI(OP_foo) in toke.c returns token UNI or FUNC1 depending on
	 * whether parens were seen. perly.y uses OPf_SPECIAL to
	 * signal whether a BASEOP had empty parens or none.
	 * Some other UNOPs are created later, though, so the best
	 * test is OPf_KIDS, which is set in newUNOP.
	 */
	return (o->op_flags & OPf_KIDS) ? OPc_UNOP : OPc_BASEOP;

    case OA_FILESTATOP:
	/*
	 * The file stat OPs are created via UNI(OP_foo) in toke.c but use
	 * the OPf_REF flag to distinguish between OP types instead of the
	 * usual OPf_SPECIAL flag. As usual, if OPf_KIDS is set, then we
	 * return OPc_UNOP so that walkoptree can find our children. If
	 * OPf_KIDS is not set then we check OPf_REF. Without OPf_REF set
	 * (no argument to the operator) it's an OP; with OPf_REF set it's
	 * an SVOP (and op_sv is the GV for the filehandle argument).
	 */
	return ((o->op_flags & OPf_KIDS) ? OPc_UNOP :
#ifdef USE_ITHREADS
		(o->op_flags & OPf_REF) ? OPc_PADOP : OPc_BASEOP);
#else
		(o->op_flags & OPf_REF) ? OPc_SVOP : OPc_BASEOP);
#endif
    case OA_LOOPEXOP:
	/*
	 * next, last, redo, dump and goto use OPf_SPECIAL to indicate that a
	 * label was omitted (in which case it's a BASEOP) or else a term was
	 * seen. In this last case, all except goto are definitely PVOP but
	 * goto is either a PVOP (with an ordinary constant label), an UNOP
	 * with OPf_STACKED (with a non-constant non-sub) or an UNOP for
	 * OP_REFGEN (with goto &sub) in which case OPf_STACKED also seems to
	 * get set.
	 */
	if (o->op_flags & OPf_STACKED)
	    return OPc_UNOP;
	else if (o->op_flags & OPf_SPECIAL)
	    return OPc_BASEOP;
	else
	    return OPc_PVOP;
    }
    warn("can't determine class of operator %s, assuming BASEOP\n",
	 OP_NAME(o));
    return OPc_BASEOP;
}

static SV *
make_op_object(pTHX_ const OP *o)
{
    SV *opsv = sv_newmortal();
    sv_setiv(newSVrv(opsv, opclassnames[cc_opclass(aTHX_ o)]), PTR2IV(o));
    return opsv;
}

static SV *
make_sv_object(pTHX_ SV *sv)
{
    SV *const arg = sv_newmortal();
    const char *type = 0;
    IV iv;
    dMY_CXT;

    for (iv = 0; iv < (IV)(sizeof(specialsv_list)/sizeof(SV*)); iv++) {
	if (sv == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (!type) {
	type = svclassnames[SvTYPE(sv)];
	iv = PTR2IV(sv);
    }
    sv_setiv(newSVrv(arg, type), iv);
    return arg;
}

#if PERL_VERSION >= 9
static SV *
make_temp_object(pTHX_ SV *temp)
{
    SV *target;
    SV *arg = sv_newmortal();
    const char *const type = svclassnames[SvTYPE(temp)];
    const IV iv = PTR2IV(temp);

    target = newSVrv(arg, type);
    sv_setiv(target, iv);

    /* Need to keep our "temp" around as long as the target exists.
       Simplest way seems to be to hang it from magic, and let that clear
       it up.  No vtable, so won't actually get in the way of anything.  */
    sv_magicext(target, temp, PERL_MAGIC_sv, NULL, NULL, 0);
    /* magic object has had its reference count increased, so we must drop
       our reference.  */
    SvREFCNT_dec(temp);
    return arg;
}

static SV *
make_warnings_object(pTHX_ const COP *const cop)
{
    const STRLEN *const warnings = cop->cop_warnings;
    const char *type = 0;
    dMY_CXT;
    IV iv = sizeof(specialsv_list)/sizeof(SV*);

    /* Counting down is deliberate. Before the split between make_sv_object
       and make_warnings_obj there appeared to be a bug - Nullsv and pWARN_STD
       were both 0, so you could never get a B::SPECIAL for pWARN_STD  */

    while (iv--) {
	if ((SV*)warnings == specialsv_list[iv]) {
	    type = "B::SPECIAL";
	    break;
	}
    }
    if (type) {
	SV *arg = sv_newmortal();
	sv_setiv(newSVrv(arg, type), iv);
	return arg;
    } else {
	/* B assumes that warnings are a regular SV. Seems easier to keep it
	   happy by making them into a regular SV.  */
	return make_temp_object(aTHX_ newSVpvn((char *)(warnings + 1), *warnings));
    }
}

static SV *
make_cop_io_object(pTHX_ COP *cop)
{
    SV *const value = newSV(0);

    Perl_emulate_cop_io(aTHX_ cop, value);

    if(SvOK(value)) {
	return make_sv_object(aTHX_ value);
    } else {
	SvREFCNT_dec(value);
	return make_sv_object(aTHX_ NULL);
    }
}
#endif

static SV *
make_mg_object(pTHX_ MAGIC *mg)
{
    SV *arg = sv_newmortal();
    sv_setiv(newSVrv(arg, "B::MAGIC"), PTR2IV(mg));
    return arg;
}

static SV *
cstring(pTHX_ SV *sv, bool perlstyle)
{
    SV *sstr;

    if (!SvOK(sv))
	return newSVpvs_flags("0", SVs_TEMP);

    sstr = newSVpvs_flags("\"", SVs_TEMP);

    if (perlstyle && SvUTF8(sv)) {
	SV *tmpsv = sv_newmortal(); /* Temporary SV to feed sv_uni_display */
	const STRLEN len = SvCUR(sv);
	const char *s = sv_uni_display(tmpsv, sv, 8*len, UNI_DISPLAY_QQ);
	while (*s)
	{
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (*s == '@')
		sv_catpvs(sstr, "\\@");
	    else if (*s == '\\')
	    {
		if (strchr("nrftax\\",*(s+1)))
		    sv_catpvn(sstr, s++, 2);
		else
		    sv_catpvs(sstr, "\\\\");
	    }
	    else /* should always be printable */
		sv_catpvn(sstr, s, 1);
	    ++s;
	}
    }
    else
    {
	/* XXX Optimise? */
	STRLEN len;
	const char *s = SvPV(sv, len);
	for (; len; len--, s++)
	{
	    /* At least try a little for readability */
	    if (*s == '"')
		sv_catpvs(sstr, "\\\"");
	    else if (*s == '\\')
		sv_catpvs(sstr, "\\\\");
            /* trigraphs - bleagh */
            else if (!perlstyle && *s == '?' && len>=3 && s[1] == '?') {
                Perl_sv_catpvf(aTHX_ sstr, "\\%03o", '?');
            }
	    else if (perlstyle && *s == '$')
		sv_catpvs(sstr, "\\$");
	    else if (perlstyle && *s == '@')
		sv_catpvs(sstr, "\\@");
#ifdef EBCDIC
	    else if (isPRINT(*s))
#else
	    else if (*s >= ' ' && *s < 127)
#endif /* EBCDIC */
		sv_catpvn(sstr, s, 1);
	    else if (*s == '\n')
		sv_catpvs(sstr, "\\n");
	    else if (*s == '\r')
		sv_catpvs(sstr, "\\r");
	    else if (*s == '\t')
		sv_catpvs(sstr, "\\t");
	    else if (*s == '\a')
		sv_catpvs(sstr, "\\a");
	    else if (*s == '\b')
		sv_catpvs(sstr, "\\b");
	    else if (*s == '\f')
		sv_catpvs(sstr, "\\f");
	    else if (!perlstyle && *s == '\v')
		sv_catpvs(sstr, "\\v");
	    else
	    {
		/* Don't want promotion of a signed -1 char in sprintf args */
		const unsigned char c = (unsigned char) *s;
		Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
	    }
	    /* XXX Add line breaks if string is long */
	}
    }
    sv_catpvs(sstr, "\"");
    return sstr;
}

static SV *
cchar(pTHX_ SV *sv)
{
    SV *sstr = newSVpvs_flags("'", SVs_TEMP);
    const char *s = SvPV_nolen(sv);
    /* Don't want promotion of a signed -1 char in sprintf args */
    const unsigned char c = (unsigned char) *s;

    if (c == '\'')
	sv_catpvs(sstr, "\\'");
    else if (c == '\\')
	sv_catpvs(sstr, "\\\\");
#ifdef EBCDIC
    else if (isPRINT(c))
#else
    else if (c >= ' ' && c < 127)
#endif /* EBCDIC */
	sv_catpvn(sstr, s, 1);
    else if (c == '\n')
	sv_catpvs(sstr, "\\n");
    else if (c == '\r')
	sv_catpvs(sstr, "\\r");
    else if (c == '\t')
	sv_catpvs(sstr, "\\t");
    else if (c == '\a')
	sv_catpvs(sstr, "\\a");
    else if (c == '\b')
	sv_catpvs(sstr, "\\b");
    else if (c == '\f')
	sv_catpvs(sstr, "\\f");
    else if (c == '\v')
	sv_catpvs(sstr, "\\v");
    else
	Perl_sv_catpvf(aTHX_ sstr, "\\%03o", c);
    sv_catpvs(sstr, "'");
    return sstr;
}

#if PERL_VERSION >= 9
#  define PMOP_pmreplstart(o)	o->op_pmstashstartu.op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplrootu.op_pmreplroot
#else
#  define PMOP_pmreplstart(o)	o->op_pmreplstart
#  define PMOP_pmreplroot(o)	o->op_pmreplroot
#  define PMOP_pmpermflags(o)	o->op_pmpermflags
#  define PMOP_pmdynflags(o)      o->op_pmdynflags
#endif

static SV *
walkoptree(pTHX_ OP *o, const char *method, SV *ref)
{
    dSP;
    OP *kid;
    SV *object;
    const char *const classname = opclassnames[cc_opclass(aTHX_ o)];
    dMY_CXT;

    /* Check that no-one has changed our reference, or is holding a reference
       to it.  */
    if (SvREFCNT(ref) == 1 && SvROK(ref) && SvTYPE(ref) == SVt_RV
	&& (object = SvRV(ref)) && SvREFCNT(object) == 1
	&& SvTYPE(object) == SVt_PVMG && SvIOK_only(object)
	&& !SvMAGICAL(object) && !SvMAGIC(object) && SvSTASH(object)) {
	/* Looks good, so rebless it for the class we need:  */
	sv_bless(ref, gv_stashpv(classname, GV_ADD));
    } else {
	/* Need to make a new one. */
	ref = sv_newmortal();
	object = newSVrv(ref, classname);
    }
    sv_setiv(object, PTR2IV(o));

    if (walkoptree_debug) {
	PUSHMARK(sp);
	XPUSHs(ref);
	PUTBACK;
	perl_call_method("walkoptree_debug", G_DISCARD);
    }
    PUSHMARK(sp);
    XPUSHs(ref);
    PUTBACK;
    perl_call_method(method, G_DISCARD);
    if (o && (o->op_flags & OPf_KIDS)) {
	for (kid = ((UNOP*)o)->op_first; kid; kid = kid->op_sibling) {
	    ref = walkoptree(aTHX_ kid, method, ref);
	}
    }
    if (o && (cc_opclass(aTHX_ o) == OPc_PMOP) && o->op_type != OP_PUSHRE
           && (kid = PMOP_pmreplroot(cPMOPo)))
    {
	ref = walkoptree(aTHX_ kid, method, ref);
    }
    return ref;
}

static SV **
oplist(pTHX_ OP *o, SV **SP)
{
    for(; o; o = o->op_next) {
#if PERL_VERSION >= 9
	if (o->op_opt == 0)
	    break;
	o->op_opt = 0;
#else
	if (o->op_seq == 0)
	    break;
	o->op_seq = 0;
#endif
	XPUSHs(make_op_object(aTHX_ o));
        switch (o->op_type) {
	case OP_SUBST:
            SP = oplist(aTHX_ PMOP_pmreplstart(cPMOPo), SP);
            continue;
	case OP_SORT:
	    if (o->op_flags & OPf_STACKED && o->op_flags & OPf_SPECIAL) {
		OP *kid = cLISTOPo->op_first->op_sibling;   /* pass pushmark */
		kid = kUNOP->op_first;                      /* pass rv2gv */
		kid = kUNOP->op_first;                      /* pass leave */
		SP = oplist(aTHX_ kid->op_next, SP);
	    }
	    continue;
        }
	switch (PL_opargs[o->op_type] & OA_CLASS_MASK) {
	case OA_LOGOP:
	    SP = oplist(aTHX_ cLOGOPo->op_other, SP);
	    break;
	case OA_LOOP:
	    SP = oplist(aTHX_ cLOOPo->op_lastop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_nextop, SP);
	    SP = oplist(aTHX_ cLOOPo->op_redoop, SP);
	    break;
	}
    }
    return SP;
}

typedef OP	*B__OP;
typedef UNOP	*B__UNOP;
typedef BINOP	*B__BINOP;
typedef LOGOP	*B__LOGOP;
typedef LISTOP	*B__LISTOP;
typedef PMOP	*B__PMOP;
typedef SVOP	*B__SVOP;
typedef PADOP	*B__PADOP;
typedef PVOP	*B__PVOP;
typedef LOOP	*B__LOOP;
typedef COP	*B__COP;

typedef SV	*B__SV;
typedef SV	*B__IV;
typedef SV	*B__PV;
typedef SV	*B__NV;
typedef SV	*B__PVMG;
#if PERL_VERSION >= 11
typedef SV	*B__REGEXP;
#endif
typedef SV	*B__PVLV;
typedef SV	*B__BM;
typedef SV	*B__RV;
typedef SV	*B__FM;
typedef AV	*B__AV;
typedef HV	*B__HV;
typedef CV	*B__CV;
typedef GV	*B__GV;
typedef IO	*B__IO;

typedef MAGIC	*B__MAGIC;
typedef HE      *B__HE;
#if PERL_VERSION >= 9
typedef struct refcounted_he	*B__RHE;
#endif

#ifdef MULTIPLICITY
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_i32 = offsetof(struct interpreter, prefix##var); } STMT_END
#else
#  define ASSIGN_COMMON_ALIAS(prefix, var) \
    STMT_START { XSANY.any_ptr = (void *)&PL_##var; } STMT_END
#endif

/* This needs to be ALIASed in a custom way, hence can't easily be defined as
   a regular XSUB.  */
static XSPROTO(intrpvar_sv_common); /* prototype to pass -Wmissing-prototypes */
static XSPROTO(intrpvar_sv_common)
{
    dVAR;
    dXSARGS;
    SV *ret;
    if (items != 0)
       croak_xs_usage(cv,  "");
#ifdef MULTIPLICITY
    ret = *(SV **)(XSANY.any_i32 + (char *)my_perl);
#else
    ret = *(SV **)(XSANY.any_ptr);
#endif
    ST(0) = make_sv_object(aTHX_ ret);
    XSRETURN(1);
}

#include "const-c.inc"

#line 650 "B.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 792 "B.c"

/* INCLUDE:  Including 'const-xs.inc' from 'B.xs' */


/* INCLUDE: Returning to 'B.xs' from 'const-xs.inc' */


XS_EUPXS(XS_B_amagic_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_amagic_generation)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	long	RETVAL;
	dXSTARG;
#line 694 "B.xs"
	RETVAL = PL_amagic_generation;
#line 811 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_comppadlist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_comppadlist)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 701 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)(PL_main_cv ? CvPADLIST(PL_main_cv)
						     : CvPADLIST(PL_compcv))));
#line 830 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sv_undef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sv_undef)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 710 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix > 1 ? &PL_sv_yes
					  : ix < 1 ? &PL_sv_undef
						   : &PL_sv_no));
#line 851 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_main_root); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_main_root)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 719 "B.xs"
	PUSHs(make_op_object(aTHX_ ix ? PL_main_start : PL_main_root));
#line 870 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_sub_generation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_sub_generation)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	UV	RETVAL;
	dXSTARG;
#line 726 "B.xs"
	RETVAL = ix ? PL_dowarn : PL_sub_generation;
#line 889 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_walkoptree); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "op, method");
    {
	B__OP	op;
	const char *	method = (const char *)SvPV_nolen(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    op = INT2PTR(B__OP,tmp);
	}
	else
	    croak("op is not a reference")
;
#line 735 "B.xs"
	(void) walkoptree(aTHX_ op, method, &PL_sv_undef);
#line 916 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_walkoptree_debug); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_walkoptree_debug)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    {
	int	RETVAL;
	dXSTARG;
#line 740 "B.xs"
	dMY_CXT;
	RETVAL = walkoptree_debug;
	if (items > 0 && SvTRUE(ST(1)))
	    walkoptree_debug = 1;
#line 935 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define address(sv) PTR2IV(sv)

XS_EUPXS(XS_B_address); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_address)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = address(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_svref_2object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_svref_2object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 757 "B.xs"
	if (!SvROK(sv))
	    croak("argument is not a reference");
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 977 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_opnumber); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_opnumber)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	const char *	name = (const char *)SvPV_nolen(ST(0))
;
#line 765 "B.xs"
{
 int i; 
 IV  result = -1;
 ST(0) = sv_newmortal();
 if (strncmp(name,"pp_",3) == 0)
   name += 3;
 for (i = 0; i < PL_maxo; i++)
  {
   if (strcmp(name, PL_op_name[i]) == 0)
    {
     result = i;
     break;
    }
  }
 sv_setiv(ST(0),result);
}
#line 1010 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_ppname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_ppname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "opnum");
    {
	int	opnum = (int)SvIV(ST(0))
;
#line 786 "B.xs"
	ST(0) = sv_newmortal();
	if (opnum >= 0 && opnum < PL_maxo)
	    Perl_sv_setpvf(aTHX_ ST(0), "pp_%s", PL_op_name[opnum]);
#line 1029 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
#line 794 "B.xs"
	STRLEN len;
	U32 hash = 0;
	const char *s = SvPVbyte(sv, len);
	PERL_HASH(hash, s, len);
	ST(0) = sv_2mortal(Perl_newSVpvf(aTHX_ "0x%"UVxf, (UV)hash));
#line 1050 "B.c"
    }
    XSRETURN(1);
}

#define cast_I32(foo) (I32)foo

XS_EUPXS(XS_B_cast_I32); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cast_I32)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	IV	i = (IV)SvIV(ST(0))
;
	IV	RETVAL;
	dXSTARG;

	RETVAL = cast_I32(i);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B_minus_c); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_minus_c)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 810 "B.xs"
	if (ix)
	    PL_savebegin = TRUE;
	else
	    PL_minus_c = TRUE;
#line 1089 "B.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_B_cstring); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_cstring)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0)
;
#line 822 "B.xs"
	PUSHs(ix == 2 ? cchar(aTHX_ sv) : cstring(aTHX_ sv, (bool)ix));
#line 1109 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B_threadsv_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B_threadsv_names)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 827 "B.xs"
#if PERL_VERSION <= 8
# ifdef USE_5005THREADS
	int i;
	const STRLEN len = strlen(PL_threadsv_names);

	EXTEND(sp, len);
	for (i = 0; i < len; i++)
	    PUSHs(newSVpvn_flags(&PL_threadsv_names[i], 1, SVs_TEMP));
# endif
#endif
#line 1136 "B.c"
	PUTBACK;
	return;
    }
}

#define SVp		0x00000
#define U32p		0x10000
#define line_tp		0x20000
#define OPp		0x30000
#define PADOFFSETp	0x40000
#define U8p		0x50000
#define IVp		0x60000
#define char_pp		0x70000
#define OP_next_ix		OPp | offsetof(struct op, op_next)
#define OP_sibling_ix		OPp | offsetof(struct op, op_sibling)
#define UNOP_first_ix		OPp | offsetof(struct unop, op_first)
#define BINOP_last_ix		OPp | offsetof(struct binop, op_last)
#define LOGOP_other_ix		OPp | offsetof(struct logop, op_other)
#if PERL_VERSION >= 9
#  define PMOP_pmreplstart_ix \
		OPp | offsetof(struct pmop, op_pmstashstartu.op_pmreplstart)
#else
#  define PMOP_pmreplstart_ix	OPp | offsetof(struct pmop, op_pmreplstart)
#endif
#define LOOP_redoop_ix		OPp | offsetof(struct loop, op_redoop)
#define LOOP_nextop_ix		OPp | offsetof(struct loop, op_nextop)
#define LOOP_lastop_ix		OPp | offsetof(struct loop, op_lastop)
#define OP_targ_ix		PADOFFSETp | offsetof(struct op, op_targ)
#define OP_flags_ix		U8p | offsetof(struct op, op_flags)
#define OP_private_ix		U8p | offsetof(struct op, op_private)
#define PMOP_pmflags_ix		U32p | offsetof(struct pmop, op_pmflags)
#ifdef USE_ITHREADS
#define PMOP_pmoffset_ix	IVp | offsetof(struct pmop, op_pmoffset)
#endif
#define SVOP_sv_ix		SVp | offsetof(struct svop, op_sv)
#define SVOP_gv_ix		SVp | offsetof(struct svop, op_sv)
#define PADOP_padix_ix		PADOFFSETp | offsetof(struct padop, op_padix)
#define COP_seq_ix		U32p | offsetof(struct cop, cop_seq)
#define COP_line_ix		line_tp | offsetof(struct cop, cop_line)
#if PERL_VERSION >= 9
#define COP_hints_ix		U32p | offsetof(struct cop, cop_hints)
#else
#define COP_hints_ix		U8p | offsetof(struct cop, op_private)
#endif
#ifdef USE_ITHREADS
#define COP_stashpv_ix		char_pp | offsetof(struct cop, cop_stashpv)
#define COP_file_ix		char_pp | offsetof(struct cop, cop_file)
#else
#define COP_stash_ix		SVp | offsetof(struct cop, cop_stash)
#define COP_filegv_ix		SVp | offsetof(struct cop, cop_filegv)
#endif

XS_EUPXS(XS_B__OP_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	size_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 900 "B.xs"
	RETVAL = opsizes[cc_opclass(aTHX_ o)];
#line 1209 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__OP_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_next)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;
#line 931 "B.xs"
	char *ptr;
	SV *ret;
#line 1230 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 934 "B.xs"
	ptr = (ix & 0xFFFF) + (char *)o;
	switch ((U8)(ix >> 16)) {
	case (U8)(OPp >> 16):
	    ret = make_op_object(aTHX_ *((OP **)ptr));
	    break;
	case (U8)(PADOFFSETp >> 16):
	    ret = sv_2mortal(newSVuv(*((PADOFFSET*)ptr)));
	    break;
	case (U8)(U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8*)ptr)));
	    break;
	case (U8)(U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	case (U8)(SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(line_tp >> 16):
	    ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
	    break;
#ifdef USE_ITHREADS
	case (U8)(IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV*)ptr)));
	    break;
	case (U8)(char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
#endif
	default:
	    croak("Illegal alias 0x%08x for B::*next", (unsigned)ix);

	}
	ST(0) = ret;
	XSRETURN(1);
#line 1274 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__OP_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_name)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 975 "B.xs"
	RETVAL = (char *)(ix ? OP_DESC(o) : OP_NAME(o));
#line 1302 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__OP_ppaddr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_ppaddr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
#line 983 "B.xs"
	int i;
	SV *sv;
#line 1320 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 986 "B.xs"
	sv = sv_2mortal(Perl_newSVpvf(aTHX_ "PL_ppaddr[OP_%s]",
				      PL_op_name[o->op_type]));
	for (i=13; (STRLEN)i < SvCUR(sv); ++i)
	    SvPVX(sv)[i] = toUPPER(SvPVX(sv)[i]);
	ST(0) = sv;
#line 1335 "B.c"
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1001 "B.xs"
	switch(ix) {
	  case 1:
	    RETVAL = o->op_opt;
	    break;
	  case 2:
	    RETVAL = o->op_spare;
	    break;
	  default:
	    RETVAL = o->op_type;
	}
#line 1374 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAB 1


XS_EUPXS(XS_B__OP_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__OP	o;
	UV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1022 "B.xs"
	switch(ix) {
	  case 1:
	    RETVAL = o->op_seq;
	    break;
	  default:
	    RETVAL = o->op_type;
	}
#line 1411 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__OP_oplist); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__OP_oplist)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__OP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__OP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1038 "B.xs"
	SP = oplist(aTHX_ o, SP);
#line 1439 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__LISTOP_children); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__LISTOP_children)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__LISTOP	o;
	OP *	kid;
	int	i;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__LISTOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1048 "B.xs"
	i = 0;
	for (kid = o->op_first; kid; kid = kid->op_sibling)
	    i++;
	RETVAL = i;
#line 1471 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION <= 8
#define XSubPPtmpAAAC 1


XS_EUPXS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmreplroot)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	OP *	root;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1064 "B.xs"
	root = o->op_pmreplroot;
	/* OP_PUSHRE stores an SV* instead of an OP* in op_pmreplroot */
	if (o->op_type == OP_PUSHRE) {
	    ST(0) = sv_newmortal();
#  ifdef USE_ITHREADS
            sv_setiv(ST(0), INT2PTR(PADOFFSET,root) );
#  else
	    sv_setiv(newSVrv(ST(0), root ?
			     svclassnames[SvTYPE((SV*)root)] : "B::SV"),
		     PTR2IV(root));
#  endif
	}
	else {
	    ST(0) = make_op_object(aTHX_ root);
	}
#line 1514 "B.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1


XS_EUPXS(XS_B__PMOP_pmreplroot); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmreplroot)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1086 "B.xs"
	if (o->op_type == OP_PUSHRE) {
#  ifdef USE_ITHREADS
	    ST(0) = sv_newmortal();
            sv_setiv(ST(0), o->op_pmreplrootu.op_pmtargetoff);
#  else
	    GV *const target = o->op_pmreplrootu.op_pmtargetgv;
	    ST(0) = sv_newmortal();
	    sv_setiv(newSVrv(ST(0), target ?
			     svclassnames[SvTYPE((SV*)target)] : "B::SV"),
		     PTR2IV(target));
#  endif
	}
	else {
	    OP *const root = o->op_pmreplrootu.op_pmreplroot; 
	    ST(0) = make_op_object(aTHX_ root);
	}
#line 1556 "B.c"
    }
    XSRETURN(1);
}

#endif
#ifdef USE_ITHREADS
#define PMOP_pmstashpv(o)	PmopSTASHPV(o);
#define XSubPPtmpAAAE 1


XS_EUPXS(XS_B__PMOP_pmstashpv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmstashpv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;

	RETVAL = PMOP_pmstashpv(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1


XS_EUPXS(XS_B__PMOP_pmstash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmstash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1118 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *) PmopSTASH(o)));
#line 1616 "B.c"
	PUTBACK;
	return;
    }
}

#endif
#if PERL_VERSION < 9
#define XSubPPtmpAAAG 1


XS_EUPXS(XS_B__PMOP_pmnext); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmnext)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PMOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1128 "B.xs"
	PUSHs(make_op_object(aTHX_ o->op_pmnext));
#line 1647 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PMOP_pmpermflags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmpermflags)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;

	RETVAL = PMOP_pmpermflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PMOP_pmdynflags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_pmdynflags)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;

	RETVAL = PMOP_pmdynflags(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__PMOP_precomp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PMOP_precomp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PMOP	o;
#line 1144 "B.xs"
	dXSI32;
	REGEXP *rx;
#line 1718 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PMOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1147 "B.xs"
	rx = PM_GETRE(o);
	ST(0) = sv_newmortal();
	if (rx) {
#if PERL_VERSION >= 9
	    if (ix) {
		sv_setuv(ST(0), RX_EXTFLAGS(rx));
	    } else
#endif
	    {
		sv_setpvn(ST(0), RX_PRECOMP(rx), RX_PRELEN(rx));
	    }
	}
#line 1740 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PADOP_sv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PADOP_sv)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PADOP	o;
#line 1188 "B.xs"
	SV *ret;
#line 1759 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PADOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1192 "B.xs"
	/* It happens that the output typemaps for B::SV and B::GV are
	   identical. The "smarts" are in make_sv_object(), which determines
	   which class to use based on SvTYPE(), rather than anything baked in
	   at compile time.  */	   
	if (o->op_padix) {
	    ret = PAD_SVl(o->op_padix);
	    if (ix && SvTYPE(ret) != SVt_PVGV)
		ret = NULL;
	} else {
	    ret = NULL;
	}
	PUSHs(make_sv_object(aTHX_ ret));
#line 1781 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PVOP_pv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PVOP_pv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__PVOP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__PVOP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1211 "B.xs"
	/*
	 * OP_TRANS uses op_pv to point to a table of 256 or >=258 shorts
	 * whereas other PVOPs point to a null terminated string.
	 */
	if ((o->op_type == OP_TRANS || o->op_type == OP_TRANSR) &&
		(o->op_private & OPpTRANS_COMPLEMENT) &&
		!(o->op_private & OPpTRANS_DELETE))
	{
	    const short* const tbl = (short*)o->op_pv;
	    const short entries = 257 + tbl[256];
	    ST(0) = newSVpvn_flags(o->op_pv, entries * sizeof(short), SVs_TEMP);
	}
	else if (o->op_type == OP_TRANS || o->op_type == OP_TRANSR) {
	    ST(0) = newSVpvn_flags(o->op_pv, 256 * sizeof(short), SVs_TEMP);
	}
	else
	    ST(0) = newSVpvn_flags(o->op_pv, strlen(o->op_pv), SVs_TEMP);
#line 1822 "B.c"
    }
    XSRETURN(1);
}

#define COP_label(o)	CopLABEL(o)
#ifdef CopSTASH_len
#define COP_stashlen(o)	CopSTASH_len(o)
#endif

XS_EUPXS(XS_B__COP_label); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_label)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	const char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;

	RETVAL = COP_label(o);
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef USE_ITHREADS
#define XSubPPtmpAAAH 1


XS_EUPXS(XS_B__COP_stash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_stash)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1253 "B.xs"
	PUSHs(make_sv_object(aTHX_
			     ix ? (SV *)CopFILEGV(o) : (SV *)CopSTASH(o)));
#line 1883 "B.c"
	PUTBACK;
	return;
    }
}

#ifdef CopSTASH_len
#define XSubPPtmpAAAI 1


XS_EUPXS(XS_B__COP_stashlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_stashlen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;

	RETVAL = COP_stashlen(o);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif
#else
#define XSubPPtmpAAAJ 1


XS_EUPXS(XS_B__COP_stashpv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_stashpv)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1272 "B.xs"
	RETVAL = ix ? CopFILE(o) : CopSTASHPV(o);
#line 1944 "B.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__COP_arybase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_arybase)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1282 "B.xs"
	RETVAL = 0;
#line 1972 "B.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__COP_warnings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_warnings)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__COP	o;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1292 "B.xs"
#if PERL_VERSION >= 9
	ST(0) = ix ? make_cop_io_object(aTHX_ o) : make_warnings_object(aTHX_ o);
#else
	ST(0) = make_sv_object(aTHX_ ix ? o->cop_io : o->cop_warnings);
#endif
	XSRETURN(1);
#line 2005 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAK 1


XS_EUPXS(XS_B__COP_hints_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__COP_hints_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "o");
    {
	B__COP	o;
	B__RHE	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    o = INT2PTR(B__COP,tmp);
	}
	else
	    croak("o is not a reference")
;
#line 1305 "B.xs"
	RETVAL = CopHINTHASH_get(o);
#line 2034 "B.c"
	ST(0) = sv_newmortal();
	sv_setiv(newSVrv(ST(0), "B::RHE"), PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#endif
#define MAGICAL_FLAG_BITS (SVs_GMG|SVs_SMG|SVs_RMG)

XS_EUPXS(XS_B__SV_REFCNT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_REFCNT)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__SV	sv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1325 "B.xs"
	RETVAL = ix ? (SvFLAGS(sv) & (U32)ix) : SvREFCNT(sv);
#line 2065 "B.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__SV_object_2svref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__SV_object_2svref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1333 "B.xs"
	ST(0) = sv_2mortal(newRV(sv));
	XSRETURN(1);
#line 2093 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_IV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvIV(sv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#define sv_SVp		0x00000
#define sv_IVp		0x10000
#define sv_UVp		0x20000
#define sv_STRLENp	0x30000
#define sv_U32p		0x40000
#define sv_U8p		0x50000
#define sv_char_pp	0x60000
#define sv_NVp		0x70000
#define sv_char_p	0x80000
#define sv_SSize_tp	0x90000
#define sv_I32p		0xA0000
#define sv_U16p		0xB0000
#define IV_ivx_ix	sv_IVp | offsetof(struct xpviv, xiv_iv)
#define IV_uvx_ix	sv_UVp | offsetof(struct xpvuv, xuv_uv)
#define NV_nvx_ix	sv_NVp | offsetof(struct xpvnv, xnv_u.xnv_nv)
#if PERL_VERSION >= 10
#define NV_cop_seq_range_low_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_cop_seq_range_high_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#define NV_parent_pad_index_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xlow)
#define NV_parent_fakelex_flags_ix \
			sv_U32p | offsetof(struct xpvnv, xnv_u.xpad_cop_seq.xhigh)
#else
#define NV_cop_seq_range_low_ix \
			sv_NVp | offsetof(struct xpvnv, xnv_nv)
#define NV_cop_seq_range_high_ix \
			sv_UVp | offsetof(struct xpvnv, xuv_uv)
#define NV_parent_pad_index_ix \
			sv_NVp | offsetof(struct xpvnv, xnv_nv)
#define NV_parent_fakelex_flags_ix \
			sv_UVp | offsetof(struct xpvnv, xuv_uv)
#endif
#define PV_cur_ix	sv_STRLENp | offsetof(struct xpv, xpv_cur)
#define PV_len_ix	sv_STRLENp | offsetof(struct xpv, xpv_len)
#define PVMG_stash_ix	sv_SVp | offsetof(struct xpvmg, xmg_stash)
#if PERL_VERSION >= 10
#  if PERL_VERSION > 14
#    define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_useful)
#    define PVBM_previous_ix	sv_UVp | offsetof(struct xpvuv, xuv_uv)
#  else
#define PVBM_useful_ix	sv_I32p | offsetof(struct xpvgv, xiv_u.xivu_i32)
#define PVBM_previous_ix    sv_U32p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_previous)
#  endif
#define PVBM_rare_ix	sv_U8p | offsetof(struct xpvgv, xnv_u.xbm_s.xbm_rare)
#else
#define PVBM_useful_ix	sv_I32p | offsetof(struct xpvbm, xbm_useful)
#define PVBM_previous_ix    sv_U16p | offsetof(struct xpvbm, xbm_previous)
#define PVBM_rare_ix	sv_U8p | offsetof(struct xpvbm, xbm_rare)
#endif
#define PVLV_targoff_ix	sv_U32p | offsetof(struct xpvlv, xlv_targoff)
#define PVLV_targlen_ix	sv_U32p | offsetof(struct xpvlv, xlv_targlen)
#define PVLV_targ_ix	sv_SVp | offsetof(struct xpvlv, xlv_targ)
#define PVLV_type_ix	sv_char_p | offsetof(struct xpvlv, xlv_type)
#if PERL_VERSION >= 10
#define PVGV_stash_ix	sv_SVp | offsetof(struct xpvgv, xnv_u.xgv_stash)
#define PVGV_flags_ix	sv_STRLENp | offsetof(struct xpvgv, xpv_cur)
#define PVIO_lines_ix	sv_IVp | offsetof(struct xpvio, xiv_iv)
#else
#define PVGV_stash_ix	sv_SVp | offsetof(struct xpvgv, xgv_stash)
#define PVGV_flags_ix	sv_U8p | offsetof(struct xpvgv, xgv_flags)
#define PVIO_lines_ix	sv_IVp | offsetof(struct xpvio, xio_lines)
#endif
#define PVIO_page_ix	    sv_IVp | offsetof(struct xpvio, xio_page)
#define PVIO_page_len_ix    sv_IVp | offsetof(struct xpvio, xio_page_len)
#define PVIO_lines_left_ix  sv_IVp | offsetof(struct xpvio, xio_lines_left)
#define PVIO_top_name_ix    sv_char_pp | offsetof(struct xpvio, xio_top_name)
#define PVIO_top_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_top_gv)
#define PVIO_fmt_name_ix    sv_char_pp | offsetof(struct xpvio, xio_fmt_name)
#define PVIO_fmt_gv_ix	    sv_SVp | offsetof(struct xpvio, xio_fmt_gv)
#define PVIO_bottom_name_ix sv_char_pp | offsetof(struct xpvio, xio_bottom_name)
#define PVIO_bottom_gv_ix   sv_SVp | offsetof(struct xpvio, xio_bottom_gv)
#define PVIO_type_ix	    sv_char_p | offsetof(struct xpvio, xio_type)
#define PVIO_flags_ix	    sv_U8p | offsetof(struct xpvio, xio_flags)
#define PVAV_max_ix	sv_SSize_tp | offsetof(struct xpvav, xav_max)
#define PVFM_lines_ix	sv_IVp | offsetof(struct xpvfm, xfm_lines)
#define PVCV_stash_ix	sv_SVp | offsetof(struct xpvcv, xcv_stash) 
#define PVCV_gv_ix	sv_SVp | offsetof(struct xpvcv, xcv_gv)
#define PVCV_file_ix	sv_char_pp | offsetof(struct xpvcv, xcv_file)
#define PVCV_depth_ix	sv_I32p | offsetof(struct xpvcv, xcv_depth)
#define PVCV_padlist_ix	sv_SVp | offsetof(struct xpvcv, xcv_padlist)
#define PVCV_outside_ix	sv_SVp | offsetof(struct xpvcv, xcv_outside)
#define PVCV_outside_seq_ix sv_U32p | offsetof(struct xpvcv, xcv_outside_seq)
#define PVCV_flags_ix	sv_U16p | offsetof(struct xpvcv, xcv_flags)
#define PVHV_max_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_max)
#if PERL_VERSION > 12
#define PVHV_keys_ix	sv_STRLENp | offsetof(struct xpvhv, xhv_keys)
#else
#define PVHV_keys_ix	sv_IVp | offsetof(struct xpvhv, xhv_keys)
#endif

XS_EUPXS(XS_B__IV_IVX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_IVX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__SV	sv;
#line 1500 "B.xs"
	char *ptr;
	SV *ret;
#line 2231 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__SV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1503 "B.xs"
	ptr = (ix & 0xFFFF) + (char *)SvANY(sv);
	switch ((U8)(ix >> 16)) {
	case (U8)(sv_SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(sv_IVp >> 16):
	    ret = sv_2mortal(newSViv(*((IV *)ptr)));
	    break;
	case (U8)(sv_UVp >> 16):
	    ret = sv_2mortal(newSVuv(*((UV *)ptr)));
	    break;
	case (U8)(sv_STRLENp >> 16):
	    ret = sv_2mortal(newSVuv(*((STRLEN *)ptr)));
	    break;
	case (U8)(sv_U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32 *)ptr)));
	    break;
	case (U8)(sv_U8p >> 16):
	    ret = sv_2mortal(newSVuv(*((U8 *)ptr)));
	    break;
	case (U8)(sv_char_pp >> 16):
	    ret = sv_2mortal(newSVpv(*((char **)ptr), 0));
	    break;
	case (U8)(sv_NVp >> 16):
	    ret = sv_2mortal(newSVnv(*((NV *)ptr)));
	    break;
	case (U8)(sv_char_p >> 16):
	    ret = newSVpvn_flags((char *)ptr, 1, SVs_TEMP);
	    break;
	case (U8)(sv_SSize_tp >> 16):
	    ret = sv_2mortal(newSViv(*((SSize_t *)ptr)));
	    break;
	case (U8)(sv_I32p >> 16):
	    ret = sv_2mortal(newSVuv(*((I32 *)ptr)));
	    break;
	case (U8)(sv_U16p >> 16):
	    ret = sv_2mortal(newSVuv(*((U16 *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*IVX", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 2284 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__IV_packiv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IV_packiv)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__IV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__IV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1553 "B.xs"
	if (ix) {
	    ST(0) = boolSV((I32)SvIVX(sv) != SvIVX(sv));
	} else if (sizeof(IV) == 8) {
	    U32 wp[2];
	    const IV iv = SvIVX(sv);
	    /*
	     * The following way of spelling 32 is to stop compilers on
	     * 32-bit architectures from moaning about the shift count
	     * being >= the width of the type. Such architectures don't
	     * reach this code anyway (unless sizeof(IV) > 8 but then
	     * everything else breaks too so I'm not fussed at the moment).
	     */
#ifdef UV_IS_QUAD
	    wp[0] = htonl(((UV)iv) >> (sizeof(UV)*4));
#else
	    wp[0] = htonl(((U32)iv) >> (sizeof(UV)*4));
#endif
	    wp[1] = htonl(iv & 0xffffffff);
	    ST(0) = newSVpvn_flags((char *)wp, 8, SVs_TEMP);
	} else {
	    U32 w = htonl((U32)SvIVX(sv));
	    ST(0) = newSVpvn_flags((char *)&w, 4, SVs_TEMP);
	}
#line 2332 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__NV_NV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__NV_NV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__NV	sv;
	NV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__NV,tmp);
	}
	else
	    croak("sv is not a reference")
;

	RETVAL = SvNV(sv);
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 11
#define XSubPPtmpAAAL 1


XS_EUPXS(XS_B__RV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__RV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__RV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1591 "B.xs"
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 2387 "B.c"
	PUTBACK;
	return;
    }
}

#else
#define XSubPPtmpAAAM 1


XS_EUPXS(XS_B__REGEXP_REGEX); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__REGEXP_REGEX)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__REGEXP	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__REGEXP,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1603 "B.xs"
	if (ix) {
	    PUSHs(newSVpvn_flags(RX_PRECOMP(sv), RX_PRELEN(sv), SVs_TEMP));
	} else {
	    dXSTARG;
	    /* FIXME - can we code this method more efficiently?  */
	    PUSHi(PTR2IV(sv));
	}
#line 2424 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__PV_RV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_RV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PV	sv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1619 "B.xs"
        if (!SvROK(sv))
            croak( "argument is not SvROK" );
	PUSHs(make_sv_object(aTHX_ SvRV(sv)));
#line 2454 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__PV_PV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PV_PV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	B__PV	sv;
#line 1631 "B.xs"
	const char *p;
	STRLEN len = 0;
	U32 utf8 = 0;
#line 2474 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PV,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1635 "B.xs"
	if (ix == 3) {
#ifndef PERL_FBM_TABLE_OFFSET
	    const MAGIC *const mg = mg_find(sv, PERL_MAGIC_bm);

	    if (!mg)
                croak("argument to B::BM::TABLE is not a PVBM");
	    p = mg->mg_ptr;
	    len = mg->mg_len;
#else
	    p = SvPV(sv, len);
	    /* Boyer-Moore table is just after string and its safety-margin \0 */
	    p += len + PERL_FBM_TABLE_OFFSET;
	    len = 256;
#endif
	} else if (ix == 2) {
	    /* This used to read 257. I think that that was buggy - should have
	       been 258. (The "\0", the flags byte, and 256 for the table.)
	       The only user of this method is B::Bytecode in B::PV::bsave.
	       I'm guessing that nothing tested the runtime correctness of
	       output of bytecompiled string constant arguments to index (etc).

	       Note the start pointer is and has always been SvPVX(sv), not
	       SvPVX(sv) + SvCUR(sv) PVBM was added in 651aa52ea1faa806, and
	       first used by the compiler in 651aa52ea1faa806. It's used to
	       get a "complete" dump of the buffer at SvPVX(), not just the
	       PVBM table. This permits the generated bytecode to "load"
	       SvPVX in "one" hit.

	       5.15 and later store the BM table via MAGIC, so the compiler
	       should handle this just fine without changes if PVBM now
	       always returns the SvPVX() buffer.  */
	    p = SvPVX_const(sv);
#ifdef PERL_FBM_TABLE_OFFSET
	    len = SvCUR(sv) + (SvVALID(sv) ? 256 + PERL_FBM_TABLE_OFFSET : 0);
#else
	    len = SvCUR(sv);
#endif
	} else if (ix) {
	    p = SvPVX(sv);
	    len = strlen(p);
	} else if (SvPOK(sv)) {
	    len = SvCUR(sv);
	    p = SvPVX_const(sv);
	    utf8 = SvUTF8(sv);
#if PERL_VERSION < 10
	    /* Before 5.10 (well 931b58fb28fa5ca7), PAD_COMPNAME_GEN was stored
	       in SvCUR(), which meant we had to attempt this special casing
	       to avoid tripping up over variable names in the pads.  */
	    if((SvLEN(sv) && len >= SvLEN(sv))) {
		/* It claims to be longer than the space allocated for it -
		   presumably it's a variable name in the pad  */
		len = strlen(p);
	    }
#endif
        }
        else {
            /* XXX for backward compatibility, but should fail */
            /* croak( "argument is not SvPOK" ); */
	    p = NULL;
        }
	ST(0) = newSVpvn_flags(p, len, SVs_TEMP | utf8);
#line 2545 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__PVMG_MAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__PVMG_MAGIC)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__PVMG	sv;
	MAGIC *	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sv = INT2PTR(B__PVMG,tmp);
	}
	else
	    croak("sv is not a reference")
;
#line 1704 "B.xs"
	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic)
	    XPUSHs(make_mg_object(aTHX_ mg));
#line 2573 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__MAGIC_MOREMAGIC); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__MAGIC_MOREMAGIC)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "mg");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__MAGIC	mg;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    mg = INT2PTR(B__MAGIC,tmp);
	}
	else
	    croak("mg is not a reference")
;
#line 1722 "B.xs"
	switch (ix) {
	case 0:
	    XPUSHs(mg->mg_moremagic ? make_mg_object(aTHX_ mg->mg_moremagic)
				    : &PL_sv_undef);
	    break;
	case 1:
	    mPUSHu(mg->mg_private);
	    break;
	case 2:
	    PUSHs(newSVpvn_flags(&(mg->mg_type), 1, SVs_TEMP));
	    break;
	case 3:
	    mPUSHu(mg->mg_flags);
	    break;
	case 4:
	    mPUSHi(mg->mg_len);
	    break;
	case 5:
	    PUSHs(make_sv_object(aTHX_ mg->mg_obj));
	    break;
	case 6:
	    if (mg->mg_ptr) {
		if (mg->mg_len >= 0) {
		    PUSHs(newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP));
		} else if (mg->mg_len == HEf_SVKEY) {
		    PUSHs(make_sv_object(aTHX_ (SV*)mg->mg_ptr));
		} else
		    PUSHs(sv_newmortal());
	    } else
		PUSHs(sv_newmortal());
	    break;
	case 7:
	    if(mg->mg_type == PERL_MAGIC_qr) {
                mPUSHi(PTR2IV(mg->mg_obj));
	    } else {
		croak("REGEX is only meaningful on r-magic");
	    }
	    break;
	case 8:
	    if (mg->mg_type == PERL_MAGIC_qr) {
		REGEXP *rx = (REGEXP *)mg->mg_obj;
		PUSHs(newSVpvn_flags(rx ? RX_PRECOMP(rx) : NULL,
				     rx ? RX_PRELEN(rx) : 0, SVs_TEMP));
	    } else {
		croak( "precomp is only meaningful on r-magic" );
	    }
	    break;
	}
#line 2648 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__GV_NAME); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_NAME)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1780 "B.xs"
#if PERL_VERSION >= 10
	ST(0) = sv_2mortal(newSVhek(!ix ? GvNAME_HEK(gv)
					: (ix == 1 ? GvFILE_HEK(gv)
						   : HvNAME_HEK((HV *)gv))));
#else
	ST(0) = !ix ? newSVpvn_flags(GvNAME(gv), GvNAMELEN(gv), SVs_TEMP)
		    : sv_2mortal(newSVpv(ix == 1 ? GvFILE(gv) : HvNAME((HV *)gv), 0))
#endif
#line 2681 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_is_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_is_empty)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1795 "B.xs"
	if (ix) {
#if PERL_VERSION >= 9
	    RETVAL = isGV_with_GP(gv) ? TRUE : FALSE;
#else
	    RETVAL = TRUE; /* In 5.8 and earlier they all are.  */
#endif
	} else {
            RETVAL = GvGP(gv) == Null(GP*);
	}
#line 2715 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__GV_GP); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_GP)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    {
	B__GV	gv;
	void *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;

	RETVAL = GvGP(gv);
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}

#define GP_sv_ix	SVp | offsetof(struct gp, gp_sv)
#define GP_io_ix	SVp | offsetof(struct gp, gp_io)
#define GP_cv_ix	SVp | offsetof(struct gp, gp_cv)
#define GP_cvgen_ix	U32p | offsetof(struct gp, gp_cvgen)
#define GP_refcnt_ix	U32p | offsetof(struct gp, gp_refcnt)
#define GP_hv_ix	SVp | offsetof(struct gp, gp_hv)
#define GP_av_ix	SVp | offsetof(struct gp, gp_av)
#define GP_form_ix	SVp | offsetof(struct gp, gp_form)
#define GP_egv_ix	SVp | offsetof(struct gp, gp_egv)
#define GP_line_ix	line_tp | offsetof(struct gp, gp_line)

XS_EUPXS(XS_B__GV_SV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_SV)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;
#line 1837 "B.xs"
	GP *gp;
	char *ptr;
	SV *ret;
#line 2774 "B.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1841 "B.xs"
	gp = GvGP(gv);
	if (!gp) {
	    const GV *const gv = CvGV(cv);
	    Perl_croak(aTHX_ "NULL gp in B::GV::%s", gv ? GvNAME(gv) : "???");
	}
	ptr = (ix & 0xFFFF) + (char *)gp;
	switch ((U8)(ix >> 16)) {
	case (U8)(SVp >> 16):
	    ret = make_sv_object(aTHX_ *((SV **)ptr));
	    break;
	case (U8)(U32p >> 16):
	    ret = sv_2mortal(newSVuv(*((U32*)ptr)));
	    break;
	case (U8)(line_tp >> 16):
	    ret = sv_2mortal(newSVuv(*((line_t *)ptr)));
	    break;
	default:
	    croak("Illegal alias 0x%08x for B::*SV", (unsigned)ix);
	}
	ST(0) = ret;
	XSRETURN(1);
#line 2805 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__GV_FILEGV); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__GV_FILEGV)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "gv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__GV	gv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    gv = INT2PTR(B__GV,tmp);
	}
	else
	    croak("gv is not a reference")
;
#line 1867 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)GvFILEGV(gv)));
#line 2832 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION <= 8
#define XSubPPtmpAAAN 1


XS_EUPXS(XS_B__IO_SUBPROCESS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IO_SUBPROCESS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "io");
    {
	B__IO	io;
	short	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference")
;

	RETVAL = IoSUBPROCESS(io);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__IO_IsSTD); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__IO_IsSTD)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "io, name");
    {
	B__IO	io;
	const char*	name = (const char *)SvPV_nolen(ST(1))
;
#line 1884 "B.xs"
	PerlIO* handle = 0;
#line 2881 "B.c"
	bool	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    io = INT2PTR(B__IO,tmp);
	}
	else
	    croak("io is not a reference")
;
#line 1886 "B.xs"
	if( strEQ( name, "stdin" ) ) {
	    handle = PerlIO_stdin();
	}
	else if( strEQ( name, "stdout" ) ) {
	    handle = PerlIO_stdout();
	}
	else if( strEQ( name, "stderr" ) ) {
	    handle = PerlIO_stderr();
	}
	else {
	    croak( "Invalid value '%s'", name );
	}
	RETVAL = handle == IoIFP(io);
#line 2905 "B.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	SSize_t	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;

	RETVAL = AvFILL(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 1912 "B.xs"
	if (AvFILL(av) >= 0) {
	    SV **svp = AvARRAY(av);
	    I32 i;
	    for (i = 0; i <= AvFILL(av); i++)
		XPUSHs(make_sv_object(aTHX_ svp[i]));
	}
#line 2964 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__AV_ARRAYelt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_ARRAYelt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "av, idx");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__AV	av;
	int	idx = (int)SvIV(ST(1))
;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;
#line 1924 "B.xs"
    	if (idx >= 0 && AvFILL(av) >= 0 && idx <= AvFILL(av))
	    XPUSHs(make_sv_object(aTHX_ (AvARRAY(av)[idx])));
	else
	    XPUSHs(make_sv_object(aTHX_ NULL));
#line 2996 "B.c"
	PUTBACK;
	return;
    }
}

#if PERL_VERSION < 9
#define AvOFF(av) ((XPVAV*)SvANY(av))->xof_off
#define XSubPPtmpAAAO 1


XS_EUPXS(XS_B__AV_OFF); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_OFF)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	IV	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;

	RETVAL = AvOFF(av);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__AV_AvFLAGS); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__AV_AvFLAGS)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "av");
    {
	B__AV	av;
	U8	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    av = INT2PTR(B__AV,tmp);
	}
	else
	    croak("av is not a reference")
;

	RETVAL = AvFLAGS(av);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#endif

XS_EUPXS(XS_B__CV_CONST); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_CONST)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;

	RETVAL = CvCONST(cv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_START); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_START)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1957 "B.xs"
	PUSHs(make_op_object(aTHX_ CvISXSUB(cv) ? NULL
			     : ix ? CvROOT(cv) : CvSTART(cv)));
#line 3108 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__CV_XSUB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_XSUB)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1966 "B.xs"
	ST(0) = ix && CvCONST(cv)
	    ? make_sv_object(aTHX_ (SV *)CvXSUBANY(cv).any_ptr)
	    : sv_2mortal(newSViv(CvISXSUB(cv)
				 ? (ix ? CvXSUBANY(cv).any_iv
				       : PTR2IV(CvXSUB(cv)))
				 : 0));
#line 3139 "B.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__CV_const_sv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__CV_const_sv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__CV	cv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cv = INT2PTR(B__CV,tmp);
	}
	else
	    croak("cv is not a reference")
;
#line 1977 "B.xs"
	PUSHs(make_sv_object(aTHX_ (SV *)cv_const_sv(cv)));
#line 3165 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HV_FILL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_FILL)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	STRLEN	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvFILL(hv);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_B__HV_RITER); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_RITER)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    {
	B__HV	hv;
	I32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;

	RETVAL = HvRITER(hv);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION < 9
#define XSubPPtmpAAAP 1


XS_EUPXS(XS_B__HV_PMROOT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_PMROOT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;
	B__PMOP	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;
#line 1995 "B.xs"
	PUSHs(make_op_object(aTHX_ HvPMROOT(hv)));
#line 3248 "B.c"
	PUTBACK;
	return;
    }
}

#endif

XS_EUPXS(XS_B__HV_ARRAY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HV_ARRAY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HV	hv;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hv = INT2PTR(B__HV,tmp);
	}
	else
	    croak("hv is not a reference")
;
#line 2003 "B.xs"
	if (HvUSEDKEYS(hv) > 0) {
	    SV *sv;
	    char *key;
	    I32 len;
	    (void)hv_iterinit(hv);
	    EXTEND(sp, HvUSEDKEYS(hv) * 2);
	    while ((sv = hv_iternextsv(hv, &key, &len))) {
		mPUSHp(key, len);
		PUSHs(make_sv_object(aTHX_ sv));
	    }
	}
#line 3286 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_VAL); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_VAL)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	B__HE	he;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;
#line 2023 "B.xs"
	PUSHs(make_sv_object(aTHX_ ix ? HeSVKEY_force(he) : HeVAL(he)));
#line 3314 "B.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_B__HE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__HE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "he");
    {
	B__HE	he;
	U32	RETVAL;
	dXSTARG;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    he = INT2PTR(B__HE,tmp);
	}
	else
	    croak("he is not a reference")
;

	RETVAL = HeHASH(he);
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#if PERL_VERSION >= 9
#define XSubPPtmpAAAQ 1


XS_EUPXS(XS_B__RHE_HASH); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_B__RHE_HASH)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	B__RHE	h;
	SV *	RETVAL;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(B__RHE,tmp);
	}
	else
	    croak("h is not a reference")
;
#line 2037 "B.xs"
	RETVAL = newRV( (SV*)cophh_2hv(h, 0) );
#line 3369 "B.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#endif
#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_B); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_B)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        newXS("B::amagic_generation", XS_B_amagic_generation, file);
        newXS("B::comppadlist", XS_B_comppadlist, file);
        cv = newXS("B::sv_yes", XS_B_sv_undef, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::sv_undef", XS_B_sv_undef, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::sv_no", XS_B_sv_undef, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::main_root", XS_B_main_root, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::main_start", XS_B_main_root, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::sub_generation", XS_B_sub_generation, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::dowarn", XS_B_sub_generation, file);
        XSANY.any_i32 = 1;
        newXS("B::walkoptree", XS_B_walkoptree, file);
        newXS("B::walkoptree_debug", XS_B_walkoptree_debug, file);
        newXS("B::address", XS_B_address, file);
        newXS("B::svref_2object", XS_B_svref_2object, file);
        newXS("B::opnumber", XS_B_opnumber, file);
        newXS("B::ppname", XS_B_ppname, file);
        newXS("B::hash", XS_B_hash, file);
        newXS("B::cast_I32", XS_B_cast_I32, file);
        cv = newXS("B::save_BEGINs", XS_B_minus_c, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::minus_c", XS_B_minus_c, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::cstring", XS_B_cstring, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::perlstring", XS_B_cstring, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::cchar", XS_B_cstring, file);
        XSANY.any_i32 = 2;
        newXS("B::threadsv_names", XS_B_threadsv_names, file);
        newXS("B::OP::size", XS_B__OP_size, file);
        cv = newXS("B::PMOP::pmreplstart", XS_B__OP_next, file);
        XSANY.any_i32 = PMOP_pmreplstart_ix;
        cv = newXS("B::SVOP::sv", XS_B__OP_next, file);
        XSANY.any_i32 = SVOP_sv_ix;
        cv = newXS("B::COP::line", XS_B__OP_next, file);
        XSANY.any_i32 = COP_line_ix;
        cv = newXS("B::LOOP::lastop", XS_B__OP_next, file);
        XSANY.any_i32 = LOOP_lastop_ix;
        cv = newXS("B::OP::private", XS_B__OP_next, file);
        XSANY.any_i32 = OP_private_ix;
        cv = newXS("B::LOOP::nextop", XS_B__OP_next, file);
        XSANY.any_i32 = LOOP_nextop_ix;
        cv = newXS("B::PADOP::padix", XS_B__OP_next, file);
        XSANY.any_i32 = PADOP_padix_ix;
        cv = newXS("B::LOOP::redoop", XS_B__OP_next, file);
        XSANY.any_i32 = LOOP_redoop_ix;
        cv = newXS("B::OP::targ", XS_B__OP_next, file);
        XSANY.any_i32 = OP_targ_ix;
        cv = newXS("B::OP::flags", XS_B__OP_next, file);
        XSANY.any_i32 = OP_flags_ix;
        cv = newXS("B::COP::cop_seq", XS_B__OP_next, file);
        XSANY.any_i32 = COP_seq_ix;
        cv = newXS("B::UNOP::first", XS_B__OP_next, file);
        XSANY.any_i32 = UNOP_first_ix;
        cv = newXS("B::COP::hints", XS_B__OP_next, file);
        XSANY.any_i32 = COP_hints_ix;
        cv = newXS("B::BINOP::last", XS_B__OP_next, file);
        XSANY.any_i32 = BINOP_last_ix;
        cv = newXS("B::OP::next", XS_B__OP_next, file);
        XSANY.any_i32 = OP_next_ix;
        cv = newXS("B::PMOP::pmflags", XS_B__OP_next, file);
        XSANY.any_i32 = PMOP_pmflags_ix;
        cv = newXS("B::SVOP::gv", XS_B__OP_next, file);
        XSANY.any_i32 = SVOP_gv_ix;
        cv = newXS("B::LOGOP::other", XS_B__OP_next, file);
        XSANY.any_i32 = LOGOP_other_ix;
        cv = newXS("B::OP::sibling", XS_B__OP_next, file);
        XSANY.any_i32 = OP_sibling_ix;
        cv = newXS("B::OP::name", XS_B__OP_name, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::OP::desc", XS_B__OP_name, file);
        XSANY.any_i32 = 1;
        newXS("B::OP::ppaddr", XS_B__OP_ppaddr, file);
#if XSubPPtmpAAAA
        cv = newXS("B::OP::type", XS_B__OP_type, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::OP::spare", XS_B__OP_type, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::OP::opt", XS_B__OP_type, file);
        XSANY.any_i32 = 1;
#endif
#if XSubPPtmpAAAB
        cv = newXS("B::OP::type", XS_B__OP_type, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::OP::seq", XS_B__OP_type, file);
        XSANY.any_i32 = 1;
#endif
        newXS("B::OP::oplist", XS_B__OP_oplist, file);
        newXS("B::LISTOP::children", XS_B__LISTOP_children, file);
#if XSubPPtmpAAAC
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
#if XSubPPtmpAAAD
        newXS("B::PMOP::pmreplroot", XS_B__PMOP_pmreplroot, file);
#endif
#if XSubPPtmpAAAE
        newXS("B::PMOP::pmstashpv", XS_B__PMOP_pmstashpv, file);
#endif
#if XSubPPtmpAAAF
        newXS("B::PMOP::pmstash", XS_B__PMOP_pmstash, file);
#endif
#if XSubPPtmpAAAG
        newXS("B::PMOP::pmnext", XS_B__PMOP_pmnext, file);
        newXS("B::PMOP::pmpermflags", XS_B__PMOP_pmpermflags, file);
        newXS("B::PMOP::pmdynflags", XS_B__PMOP_pmdynflags, file);
#endif
        newXS("B::PMOP::precomp", XS_B__PMOP_precomp, file);
        cv = newXS("B::PADOP::gv", XS_B__PADOP_sv, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::PADOP::sv", XS_B__PADOP_sv, file);
        XSANY.any_i32 = 0;
        newXS("B::PVOP::pv", XS_B__PVOP_pv, file);
        newXS("B::COP::label", XS_B__COP_label, file);
#if XSubPPtmpAAAH
        cv = newXS("B::COP::filegv", XS_B__COP_stash, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::COP::stash", XS_B__COP_stash, file);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAI
        newXS("B::COP::stashlen", XS_B__COP_stashlen, file);
#endif
#endif
#if XSubPPtmpAAAJ
        cv = newXS("B::COP::file", XS_B__COP_stashpv, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::COP::stashpv", XS_B__COP_stashpv, file);
        XSANY.any_i32 = 0;
#endif
        newXS("B::COP::arybase", XS_B__COP_arybase, file);
        cv = newXS("B::COP::io", XS_B__COP_warnings, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::COP::warnings", XS_B__COP_warnings, file);
        XSANY.any_i32 = 0;
#if XSubPPtmpAAAK
        newXS("B::COP::hints_hash", XS_B__COP_hints_hash, file);
#endif
        cv = newXS("B::SV::REFCNT", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::SV::POK", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVf_POK;
        cv = newXS("B::SV::ROK", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVf_ROK;
        cv = newXS("B::SV::MAGICAL", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = MAGICAL_FLAG_BITS;
        cv = newXS("B::SV::SvTYPE", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = SVTYPEMASK;
        cv = newXS("B::SV::FLAGS", XS_B__SV_REFCNT, file);
        XSANY.any_i32 = 0xFFFFFFFF;
        newXS("B::SV::object_2svref", XS_B__SV_object_2svref, file);
        newXS("B::IV::IV", XS_B__IV_IV, file);
        cv = newXS("B::BM::PREVIOUS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVBM_previous_ix;
        cv = newXS("B::BM::USEFUL", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVBM_useful_ix;
        cv = newXS("B::IO::TOP_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_top_name_ix;
        cv = newXS("B::NV::PARENT_FAKELEX_FLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_parent_fakelex_flags_ix;
        cv = newXS("B::NV::NVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_nvx_ix;
        cv = newXS("B::CV::DEPTH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_depth_ix;
        cv = newXS("B::HV::KEYS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVHV_keys_ix;
        cv = newXS("B::HV::MAX", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVHV_max_ix;
        cv = newXS("B::IO::PAGE_LEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_page_len_ix;
        cv = newXS("B::AV::MAX", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVAV_max_ix;
        cv = newXS("B::CV::FILE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_file_ix;
        cv = newXS("B::PVLV::TYPE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_type_ix;
        cv = newXS("B::PV::LEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PV_len_ix;
        cv = newXS("B::PVMG::SvSTASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVMG_stash_ix;
        cv = newXS("B::IO::BOTTOM_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_bottom_gv_ix;
        cv = newXS("B::GV::STASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVGV_stash_ix;
        cv = newXS("B::NV::COP_SEQ_RANGE_HIGH", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_cop_seq_range_high_ix;
        cv = newXS("B::IO::IoTYPE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_type_ix;
        cv = newXS("B::CV::CvFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_flags_ix;
        cv = newXS("B::IO::FMT_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_fmt_name_ix;
        cv = newXS("B::NV::PARENT_PAD_INDEX", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_parent_pad_index_ix;
        cv = newXS("B::CV::OUTSIDE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_outside_ix;
        cv = newXS("B::GV::GvFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVGV_flags_ix;
        cv = newXS("B::IV::UVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = IV_uvx_ix;
        cv = newXS("B::CV::OUTSIDE_SEQ", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_outside_seq_ix;
        cv = newXS("B::CV::GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_gv_ix;
        cv = newXS("B::IO::LINES_LEFT", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_lines_left_ix;
        cv = newXS("B::IO::TOP_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_top_gv_ix;
        cv = newXS("B::IV::IVX", XS_B__IV_IVX, file);
        XSANY.any_i32 = IV_ivx_ix;
        cv = newXS("B::PVLV::TARG", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targ_ix;
        cv = newXS("B::IO::LINES", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_lines_ix;
        cv = newXS("B::IO::FMT_GV", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_fmt_gv_ix;
        cv = newXS("B::PVLV::TARGOFF", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targoff_ix;
        cv = newXS("B::IO::BOTTOM_NAME", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_bottom_name_ix;
        cv = newXS("B::IO::IoFLAGS", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_flags_ix;
        cv = newXS("B::PVLV::TARGLEN", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVLV_targlen_ix;
        cv = newXS("B::CV::STASH", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_stash_ix;
        cv = newXS("B::BM::RARE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVBM_rare_ix;
        cv = newXS("B::IO::PAGE", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVIO_page_ix;
        cv = newXS("B::FM::LINES", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVFM_lines_ix;
        cv = newXS("B::CV::PADLIST", XS_B__IV_IVX, file);
        XSANY.any_i32 = PVCV_padlist_ix;
        cv = newXS("B::PV::CUR", XS_B__IV_IVX, file);
        XSANY.any_i32 = PV_cur_ix;
        cv = newXS("B::NV::COP_SEQ_RANGE_LOW", XS_B__IV_IVX, file);
        XSANY.any_i32 = NV_cop_seq_range_low_ix;
        cv = newXS("B::IV::packiv", XS_B__IV_packiv, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::IV::needs64bits", XS_B__IV_packiv, file);
        XSANY.any_i32 = 1;
        newXS("B::NV::NV", XS_B__NV_NV, file);
#if XSubPPtmpAAAL
        newXS("B::RV::RV", XS_B__RV_RV, file);
#endif
#if XSubPPtmpAAAM
        cv = newXS("B::REGEXP::REGEX", XS_B__REGEXP_REGEX, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::REGEXP::precomp", XS_B__REGEXP_REGEX, file);
        XSANY.any_i32 = 1;
#endif
        newXS("B::PV::RV", XS_B__PV_RV, file);
        cv = newXS("B::PV::PV", XS_B__PV_PV, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::PV::PVX", XS_B__PV_PV, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::PV::PVBM", XS_B__PV_PV, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::BM::TABLE", XS_B__PV_PV, file);
        XSANY.any_i32 = 3;
        newXS("B::PVMG::MAGIC", XS_B__PVMG_MAGIC, file);
        cv = newXS("B::MAGIC::FLAGS", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 3;
        cv = newXS("B::MAGIC::MOREMAGIC", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::MAGIC::TYPE", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::MAGIC::OBJ", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 5;
        cv = newXS("B::MAGIC::REGEX", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 7;
        cv = newXS("B::MAGIC::PRIVATE", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::MAGIC::precomp", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 8;
        cv = newXS("B::MAGIC::PTR", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 6;
        cv = newXS("B::MAGIC::LENGTH", XS_B__MAGIC_MOREMAGIC, file);
        XSANY.any_i32 = 4;
        cv = newXS("B::GV::NAME", XS_B__GV_NAME, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::GV::FILE", XS_B__GV_NAME, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::HV::NAME", XS_B__GV_NAME, file);
        XSANY.any_i32 = 2;
        cv = newXS("B::GV::isGV_with_GP", XS_B__GV_is_empty, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::GV::is_empty", XS_B__GV_is_empty, file);
        XSANY.any_i32 = 0;
        newXS("B::GV::GP", XS_B__GV_GP, file);
        cv = newXS("B::GV::IO", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_io_ix;
        cv = newXS("B::GV::GvREFCNT", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_refcnt_ix;
        cv = newXS("B::GV::LINE", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_line_ix;
        cv = newXS("B::GV::AV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_av_ix;
        cv = newXS("B::GV::CV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_cv_ix;
        cv = newXS("B::GV::FORM", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_form_ix;
        cv = newXS("B::GV::EGV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_egv_ix;
        cv = newXS("B::GV::HV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_hv_ix;
        cv = newXS("B::GV::CVGEN", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_cvgen_ix;
        cv = newXS("B::GV::SV", XS_B__GV_SV, file);
        XSANY.any_i32 = GP_sv_ix;
        newXS("B::GV::FILEGV", XS_B__GV_FILEGV, file);
#if XSubPPtmpAAAN
        newXS("B::IO::SUBPROCESS", XS_B__IO_SUBPROCESS, file);
#endif
        newXS("B::IO::IsSTD", XS_B__IO_IsSTD, file);
        newXS("B::AV::FILL", XS_B__AV_FILL, file);
        newXS("B::AV::ARRAY", XS_B__AV_ARRAY, file);
        newXS("B::AV::ARRAYelt", XS_B__AV_ARRAYelt, file);
#if XSubPPtmpAAAO
        newXS("B::AV::OFF", XS_B__AV_OFF, file);
        newXS("B::AV::AvFLAGS", XS_B__AV_AvFLAGS, file);
#endif
        newXS("B::CV::CONST", XS_B__CV_CONST, file);
        cv = newXS("B::CV::START", XS_B__CV_START, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::CV::ROOT", XS_B__CV_START, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::CV::XSUBANY", XS_B__CV_XSUB, file);
        XSANY.any_i32 = 1;
        cv = newXS("B::CV::XSUB", XS_B__CV_XSUB, file);
        XSANY.any_i32 = 0;
        newXS("B::CV::const_sv", XS_B__CV_const_sv, file);
        newXS("B::HV::FILL", XS_B__HV_FILL, file);
        newXS("B::HV::RITER", XS_B__HV_RITER, file);
#if XSubPPtmpAAAP
        newXS("B::HV::PMROOT", XS_B__HV_PMROOT, file);
#endif
        newXS("B::HV::ARRAY", XS_B__HV_ARRAY, file);
        cv = newXS("B::HE::VAL", XS_B__HE_VAL, file);
        XSANY.any_i32 = 0;
        cv = newXS("B::HE::SVKEY_force", XS_B__HE_VAL, file);
        XSANY.any_i32 = 1;
        newXS("B::HE::HASH", XS_B__HE_HASH, file);
#if XSubPPtmpAAAQ
        newXS("B::RHE::HASH", XS_B__RHE_HASH, file);
#endif
    }

    /* Initialisation Section */

#line 2 "./const-xs.inc"
  {
#ifdef dTHX
    dTHX;
#endif
    HV *symbol_table = get_hv("B::", GV_ADD);
    AV *push = get_av("B::EXPORT_OK", GV_ADD);
    HE *he;

    static const struct iv_s values_for_iv[] =
      {
        { "CVf_ANON", 8, CVf_ANON },
        { "CVf_CLONE", 9, CVf_CLONE },
        { "CVf_CLONED", 10, CVf_CLONED },
        { "CVf_CONST", 9, CVf_CONST },
        { "CVf_LVALUE", 10, CVf_LVALUE },
        { "CVf_METHOD", 10, CVf_METHOD },
        { "CVf_NODEBUG", 11, CVf_NODEBUG },
        { "CVf_UNIQUE", 10, CVf_UNIQUE },
        { "CVf_WEAKOUTSIDE", 15, CVf_WEAKOUTSIDE },
        { "GVf_IMPORTED_AV", 15, GVf_IMPORTED_AV },
        { "GVf_IMPORTED_CV", 15, GVf_IMPORTED_CV },
        { "GVf_IMPORTED_HV", 15, GVf_IMPORTED_HV },
        { "GVf_IMPORTED_SV", 15, GVf_IMPORTED_SV },
        { "HEf_SVKEY", 9, HEf_SVKEY },
        { "SVTYPEMASK", 10, SVTYPEMASK },
        { "SVt_PVGV", 8, SVt_PVGV },
        { "SVt_PVHV", 8, SVt_PVHV },
        { "SVf_FAKE", 8, SVf_FAKE },
        { "SVf_IOK", 7, SVf_IOK },
        { "SVf_IVisUV", 10, SVf_IVisUV },
        { "SVf_NOK", 7, SVf_NOK },
        { "SVf_POK", 7, SVf_POK },
        { "SVf_READONLY", 12, SVf_READONLY },
        { "SVf_ROK", 7, SVf_ROK },
        { "SVp_IOK", 7, SVp_IOK },
        { "SVp_NOK", 7, SVp_NOK },
        { "SVp_POK", 7, SVp_POK },
        { "SVpad_OUR", 9, SVpad_OUR },
        { "SVs_RMG", 7, SVs_RMG },
        { "SVs_SMG", 7, SVs_SMG },
        { "PAD_FAKELEX_ANON", 16, PAD_FAKELEX_ANON },
        { "PAD_FAKELEX_MULTI", 17, PAD_FAKELEX_MULTI },
        { "CVf_ISXSUB", 10, CVf_ISXSUB },
        { "RXf_PMf_STD_PMMOD_SHIFT", 23, RXf_PMf_STD_PMMOD_SHIFT },
        { "RXf_PMf_MULTILINE", 17, RXf_PMf_MULTILINE },
        { "RXf_PMf_SINGLELINE", 18, RXf_PMf_SINGLELINE },
        { "RXf_PMf_FOLD", 12, RXf_PMf_FOLD },
        { "RXf_PMf_EXTENDED", 16, RXf_PMf_EXTENDED },
        { "RXf_PMf_KEEPCOPY", 16, RXf_PMf_KEEPCOPY },
        { "RXf_PMf_CHARSET", 15, RXf_PMf_CHARSET },
        { "PMf_MULTILINE", 13, PMf_MULTILINE },
        { "PMf_SINGLELINE", 14, PMf_SINGLELINE },
        { "PMf_FOLD", 8, PMf_FOLD },
        { "PMf_EXTENDED", 12, PMf_EXTENDED },
        { "PMf_KEEPCOPY", 12, PMf_KEEPCOPY },
        { "OPf_WANT", 8, OPf_WANT },
        { "OPf_WANT_VOID", 13, OPf_WANT_VOID },
        { "OPf_WANT_SCALAR", 15, OPf_WANT_SCALAR },
        { "OPf_WANT_LIST", 13, OPf_WANT_LIST },
        { "OPf_KIDS", 8, OPf_KIDS },
        { "OPf_PARENS", 10, OPf_PARENS },
        { "OPf_REF", 7, OPf_REF },
        { "OPf_MOD", 7, OPf_MOD },
        { "OPf_STACKED", 11, OPf_STACKED },
        { "OPf_SPECIAL", 11, OPf_SPECIAL },
        { "OPpLVAL_INTRO", 13, OPpLVAL_INTRO },
        { "OPpTARGET_MY", 12, OPpTARGET_MY },
        { "OPpREFCOUNTED", 13, OPpREFCOUNTED },
        { "OPpASSIGN_COMMON", 16, OPpASSIGN_COMMON },
        { "OPpASSIGN_BACKWARDS", 19, OPpASSIGN_BACKWARDS },
        { "OPpASSIGN_CV_TO_GV", 18, OPpASSIGN_CV_TO_GV },
        { "OPpRUNTIME", 10, OPpRUNTIME },
        { "OPpTRANS_FROM_UTF", 17, OPpTRANS_FROM_UTF },
        { "OPpTRANS_TO_UTF", 15, OPpTRANS_TO_UTF },
        { "OPpTRANS_IDENTICAL", 18, OPpTRANS_IDENTICAL },
        { "OPpTRANS_SQUASH", 15, OPpTRANS_SQUASH },
        { "OPpTRANS_COMPLEMENT", 19, OPpTRANS_COMPLEMENT },
        { "OPpTRANS_GROWS", 14, OPpTRANS_GROWS },
        { "OPpTRANS_DELETE", 15, OPpTRANS_DELETE },
        { "OPpREPEAT_DOLIST", 16, OPpREPEAT_DOLIST },
        { "OPpDEREF", 8, OPpDEREF },
        { "OPpDEREF_AV", 11, OPpDEREF_AV },
        { "OPpDEREF_HV", 11, OPpDEREF_HV },
        { "OPpDEREF_SV", 11, OPpDEREF_SV },
        { "OPpENTERSUB_DB", 14, OPpENTERSUB_DB },
        { "OPpENTERSUB_HASTARG", 19, OPpENTERSUB_HASTARG },
        { "OPpENTERSUB_INARGS", 18, OPpENTERSUB_INARGS },
        { "OPpENTERSUB_AMPER", 17, OPpENTERSUB_AMPER },
        { "OPpENTERSUB_NOPAREN", 19, OPpENTERSUB_NOPAREN },
        { "OPpMAY_RETURN_CONSTANT", 22, OPpMAY_RETURN_CONSTANT },
        { "OPpEARLY_CV", 11, OPpEARLY_CV },
        { "OPpLVAL_DEFER", 13, OPpLVAL_DEFER },
        { "OPpOUR_INTRO", 12, OPpOUR_INTRO },
        { "OPpMAYBE_LVSUB", 14, OPpMAYBE_LVSUB },
        { "OPpSUBSTR_REPL_FIRST", 20, OPpSUBSTR_REPL_FIRST },
        { "OPpPAD_STATE", 12, OPpPAD_STATE },
        { "OPpDONT_INIT_GV", 15, OPpDONT_INIT_GV },
        { "OPpALLOW_FAKE", 13, OPpALLOW_FAKE },
        { "OPpITER_REVERSED", 16, OPpITER_REVERSED },
        { "OPpITER_DEF", 11, OPpITER_DEF },
        { "OPpCONST_NOVER", 14, OPpCONST_NOVER },
        { "OPpCONST_SHORTCIRCUIT", 21, OPpCONST_SHORTCIRCUIT },
        { "OPpCONST_STRICT", 15, OPpCONST_STRICT },
        { "OPpCONST_ENTERED", 16, OPpCONST_ENTERED },
        { "OPpCONST_BARE", 13, OPpCONST_BARE },
        { "OPpCONST_WARNING", 16, OPpCONST_WARNING },
        { "OPpFLIP_LINENUM", 15, OPpFLIP_LINENUM },
        { "OPpLIST_GUESSED", 15, OPpLIST_GUESSED },
        { "OPpSLICE", 8, OPpSLICE },
        { "OPpEXISTS_SUB", 13, OPpEXISTS_SUB },
        { "OPpSORT_NUMERIC", 15, OPpSORT_NUMERIC },
        { "OPpSORT_INTEGER", 15, OPpSORT_INTEGER },
        { "OPpSORT_REVERSE", 15, OPpSORT_REVERSE },
        { "OPpSORT_INPLACE", 15, OPpSORT_INPLACE },
        { "OPpSORT_DESCEND", 15, OPpSORT_DESCEND },
        { "OPpSORT_QSORT", 13, OPpSORT_QSORT },
        { "OPpSORT_STABLE", 14, OPpSORT_STABLE },
        { "OPpREVERSE_INPLACE", 18, OPpREVERSE_INPLACE },
        { "OPpOPEN_IN_RAW", 14, OPpOPEN_IN_RAW },
        { "OPpOPEN_IN_CRLF", 15, OPpOPEN_IN_CRLF },
        { "OPpOPEN_OUT_RAW", 15, OPpOPEN_OUT_RAW },
        { "OPpOPEN_OUT_CRLF", 16, OPpOPEN_OUT_CRLF },
        { "OPpHUSH_VMSISH", 14, OPpHUSH_VMSISH },
        { "OPpEXIT_VMSISH", 14, OPpEXIT_VMSISH },
        { "OPpFT_ACCESS", 12, OPpFT_ACCESS },
        { "OPpFT_STACKED", 13, OPpFT_STACKED },
        { "OPpFT_STACKING", 14, OPpFT_STACKING },
        { "OPpFT_AFTER_t", 13, OPpFT_AFTER_t },
        { "OPpGREP_LEX", 11, OPpGREP_LEX },
        { "OPpEVAL_HAS_HH", 14, OPpEVAL_HAS_HH },
        { "OPpEVAL_UNICODE", 15, OPpEVAL_UNICODE },
        { "OPpEVAL_BYTES", 13, OPpEVAL_BYTES },
        { "OPpEVAL_COPHH", 13, OPpEVAL_COPHH },
        { "OPpOFFBYONE", 11, OPpOFFBYONE },
        { "OPpCOREARGS_DEREF1", 18, OPpCOREARGS_DEREF1 },
        { "OPpCOREARGS_DEREF2", 18, OPpCOREARGS_DEREF2 },
        { "OPpCOREARGS_SCALARMOD", 21, OPpCOREARGS_SCALARMOD },
        { "OPpCOREARGS_PUSHMARK", 20, OPpCOREARGS_PUSHMARK },
        { "OPpPV_IS_UTF8", 13, OPpPV_IS_UTF8 },
        { "PMf_RETAINT", 11, PMf_RETAINT },
        { "PMf_ONCE", 8, PMf_ONCE },
        { "PMf_MAYBE_CONST", 15, PMf_MAYBE_CONST },
        { "PMf_USED", 8, PMf_USED },
        { "PMf_CONST", 9, PMf_CONST },
        { "PMf_KEEP", 8, PMf_KEEP },
        { "PMf_GLOBAL", 10, PMf_GLOBAL },
        { "PMf_CONTINUE", 12, PMf_CONTINUE },
        { "PMf_EVAL", 8, PMf_EVAL },
        { "PMf_NONDESTRUCT", 15, PMf_NONDESTRUCT },
        { "OA_MARK", 7, OA_MARK },
        { "OA_FOLDCONST", 12, OA_FOLDCONST },
        { "OA_RETSCALAR", 12, OA_RETSCALAR },
        { "OA_TARGET", 9, OA_TARGET },
        { "OA_TARGLEX", 10, OA_TARGLEX },
        { "OA_OTHERINT", 11, OA_OTHERINT },
        { "OA_DANGEROUS", 12, OA_DANGEROUS },
        { "OA_DEFGV", 8, OA_DEFGV },
        { "OCSHIFT", 7, OCSHIFT },
        { "OA_CLASS_MASK", 13, OA_CLASS_MASK },
        { "OA_BASEOP", 9, OA_BASEOP },
        { "OA_UNOP", 7, OA_UNOP },
        { "OA_BINOP", 8, OA_BINOP },
        { "OA_LOGOP", 8, OA_LOGOP },
        { "OA_LISTOP", 9, OA_LISTOP },
        { "OA_PMOP", 7, OA_PMOP },
        { "OA_SVOP", 7, OA_SVOP },
        { "OA_PADOP", 8, OA_PADOP },
        { "OA_PVOP_OR_SVOP", 15, OA_PVOP_OR_SVOP },
        { "OA_LOOP", 7, OA_LOOP },
        { "OA_COP", 6, OA_COP },
        { "OA_BASEOP_OR_UNOP", 17, OA_BASEOP_OR_UNOP },
        { "OA_FILESTATOP", 13, OA_FILESTATOP },
        { "OA_LOOPEXOP", 11, OA_LOOPEXOP },
        { "OASHIFT", 7, OASHIFT },
        { "OA_SCALAR", 9, OA_SCALAR },
        { "OA_LIST", 7, OA_LIST },
        { "OA_AVREF", 8, OA_AVREF },
        { "OA_HVREF", 8, OA_HVREF },
        { "OA_CVREF", 8, OA_CVREF },
        { "OA_FILEREF", 10, OA_FILEREF },
        { "OA_SCALARREF", 12, OA_SCALARREF },
        { "OA_OPTIONAL", 11, OA_OPTIONAL },
        { "PERL_LOADMOD_DENY", 17, PERL_LOADMOD_DENY },
        { "PERL_LOADMOD_NOIMPORT", 21, PERL_LOADMOD_NOIMPORT },
        { "PERL_LOADMOD_IMPORT_OPS", 23, PERL_LOADMOD_IMPORT_OPS },
        { "BHKf_bhk_start", 14, BHKf_bhk_start },
        { "BHKf_bhk_pre_end", 16, BHKf_bhk_pre_end },
        { "BHKf_bhk_post_end", 17, BHKf_bhk_post_end },
        { "BHKf_bhk_eval", 13, BHKf_bhk_eval },
        { "RV2CVOPCV_MARK_EARLY", 20, RV2CVOPCV_MARK_EARLY },
        { "RV2CVOPCV_RETURN_NAME_GV", 24, RV2CVOPCV_RETURN_NAME_GV },
        { "OP_LVALUE_NO_CROAK", 18, OP_LVALUE_NO_CROAK },
        { "XOPf_xop_name", 13, XOPf_xop_name },
        { "XOPf_xop_desc", 13, XOPf_xop_desc },
        { "XOPf_xop_class", 14, XOPf_xop_class },
        { "XOPf_xop_peep", 13, XOPf_xop_peep },
        { "CXt_NULL", 8, CXt_NULL },
        { "CXt_WHEN", 8, CXt_WHEN },
        { "CXt_BLOCK", 9, CXt_BLOCK },
        { "CXt_GIVEN", 9, CXt_GIVEN },
        { "CXt_LOOP_FOR", 12, CXt_LOOP_FOR },
        { "CXt_LOOP_PLAIN", 14, CXt_LOOP_PLAIN },
        { "CXt_LOOP_LAZYSV", 15, CXt_LOOP_LAZYSV },
        { "CXt_LOOP_LAZYIV", 15, CXt_LOOP_LAZYIV },
        { "CXt_SUB", 7, CXt_SUB },
        { "CXt_FORMAT", 10, CXt_FORMAT },
        { "CXt_EVAL", 8, CXt_EVAL },
        { "CXt_SUBST", 9, CXt_SUBST },
        { "CXp_MULTICALL", 13, CXp_MULTICALL },
        { "CXp_HASARGS", 11, CXp_HASARGS },
        { "CXp_REAL", 8, CXp_REAL },
        { "CXp_TRYBLOCK", 12, CXp_TRYBLOCK },
        { "CXp_FOR_DEF", 11, CXp_FOR_DEF },
        { "CXp_ONCE", 8, CXp_ONCE },
        { "G_SCALAR", 8, G_SCALAR },
        { "G_ARRAY", 7, G_ARRAY },
        { "G_VOID", 6, G_VOID },
        { "G_WANT", 6, G_WANT },
        { "G_DISCARD", 9, G_DISCARD },
        { "G_EVAL", 6, G_EVAL },
        { "G_NOARGS", 8, G_NOARGS },
        { "G_KEEPERR", 9, G_KEEPERR },
        { "G_NODEBUG", 9, G_NODEBUG },
        { "G_METHOD", 8, G_METHOD },
        { "G_FAKINGEVAL", 12, G_FAKINGEVAL },
        { "G_UNDEF_FILL", 12, G_UNDEF_FILL },
        { "G_WRITING_TO_STDERR", 19, G_WRITING_TO_STDERR },
        { "EVAL_NULL", 9, EVAL_NULL },
        { "EVAL_INEVAL", 11, EVAL_INEVAL },
        { "EVAL_WARNONLY", 13, EVAL_WARNONLY },
        { "EVAL_KEEPERR", 12, EVAL_KEEPERR },
        { "EVAL_INREQUIRE", 14, EVAL_INREQUIRE },
        { "PERLSI_UNDEF", 12, PERLSI_UNDEF },
        { "PERLSI_MAIN", 11, PERLSI_MAIN },
        { "PERLSI_MAGIC", 12, PERLSI_MAGIC },
        { "PERLSI_SORT", 11, PERLSI_SORT },
        { "PERLSI_SIGNAL", 13, PERLSI_SIGNAL },
        { "PERLSI_OVERLOAD", 15, PERLSI_OVERLOAD },
        { "PERLSI_DESTROY", 14, PERLSI_DESTROY },
        { "PERLSI_WARNHOOK", 15, PERLSI_WARNHOOK },
        { "PERLSI_DIEHOOK", 14, PERLSI_DIEHOOK },
        { "PERLSI_REQUIRE", 14, PERLSI_REQUIRE },
        { "RXf_ANCH_BOL", 12, RXf_ANCH_BOL },
        { "RXf_ANCH_MBOL", 13, RXf_ANCH_MBOL },
        { "RXf_ANCH_SBOL", 13, RXf_ANCH_SBOL },
        { "RXf_ANCH_GPOS", 13, RXf_ANCH_GPOS },
        { "RXf_GPOS_SEEN", 13, RXf_GPOS_SEEN },
        { "RXf_GPOS_FLOAT", 14, RXf_GPOS_FLOAT },
        { "RXf_LOOKBEHIND_SEEN", 19, RXf_LOOKBEHIND_SEEN },
        { "RXf_EVAL_SEEN", 13, RXf_EVAL_SEEN },
        { "RXf_CANY_SEEN", 13, RXf_CANY_SEEN },
        { "RXf_NOSCAN", 10, RXf_NOSCAN },
        { "RXf_CHECK_ALL", 13, RXf_CHECK_ALL },
        { "RXf_MATCH_UTF8", 14, RXf_MATCH_UTF8 },
        { "RXf_USE_INTUIT_NOML", 19, RXf_USE_INTUIT_NOML },
        { "RXf_USE_INTUIT_ML", 17, RXf_USE_INTUIT_ML },
        { "RXf_INTUIT_TAIL", 15, RXf_INTUIT_TAIL },
        { "RXf_SPLIT", 9, RXf_SPLIT },
        { "RXf_COPY_DONE", 13, RXf_COPY_DONE },
        { "RXf_TAINTED_SEEN", 16, RXf_TAINTED_SEEN },
        { "RXf_TAINTED", 11, RXf_TAINTED },
        { "RXf_START_ONLY", 14, RXf_START_ONLY },
        { "RXf_SKIPWHITE", 13, RXf_SKIPWHITE },
        { "RXf_WHITE", 9, RXf_WHITE },
        { NULL, 0, 0 } };
	const struct iv_s *value_for_iv = values_for_iv;
        while (value_for_iv->name) {
	    he = _add_symbol(aTHX_  symbol_table, value_for_iv->name,
				     value_for_iv->namelen, newSViv(value_for_iv->value));
	    av_push(push, newSVhek(HeKEY_hek(he)));
            ++value_for_iv;
	}
	if (C_ARRAY_LENGTH(values_for_notfound) > 1) {
#ifndef SYMBIAN
	    HV *const _missing = get_missing_hash(aTHX);
#endif
	    const struct notfound_s *value_for_notfound = values_for_notfound;
	    do {

		/* Need to add prototypes, else parsing will vary by platform.  */
		HE *he = (HE*) hv_common_key_len(symbol_table,
						 value_for_notfound->name,
						 value_for_notfound->namelen,
						 HV_FETCH_LVALUE, NULL, 0);
		SV *sv;
#ifndef SYMBIAN
		HEK *hek;
#endif
		if (!he) {
		    Perl_croak(aTHX_ 
			       "Couldn't add key '%s' to %%B::",
			       value_for_notfound->name);
		}
		sv = HeVAL(he);
		if (!SvOK(sv) && SvTYPE(sv) != SVt_PVGV) {
		    /* Nothing was here before, so mark a prototype of ""  */
		    sv_setpvn(sv, "", 0);
		} else if (SvPOK(sv) && SvCUR(sv) == 0) {
		    /* There is already a prototype of "" - do nothing  */
		} else {
		    /* Someone has been here before us - have to make a real
		       typeglob.  */
		    /* It turns out to be incredibly hard to deal with all the
		       corner cases of sub foo (); and reporting errors correctly,
		       so lets cheat a bit.  Start with a constant subroutine  */
		    CV *cv = newCONSTSUB(symbol_table,
					 value_for_notfound->name,
					 &PL_sv_yes);
		    /* and then turn it into a non constant declaration only.  */
		    SvREFCNT_dec(CvXSUBANY(cv).any_ptr);
		    CvCONST_off(cv);
		    CvXSUB(cv) = NULL;
		    CvXSUBANY(cv).any_ptr = NULL;
		}
#ifndef SYMBIAN
		hek = HeKEY_hek(he);
		if (!hv_common(_missing, NULL, HEK_KEY(hek),
 			       HEK_LEN(hek), HEK_FLAGS(hek), HV_FETCH_ISSTORE,
			       &PL_sv_yes, HEK_HASH(hek)))
		    Perl_croak(aTHX_  "Couldn't add key '%s' to missing_hash",
			       value_for_notfound->name);
#endif
		av_push(push, newSVhek(hek));
	    } while ((++value_for_notfound)->name);
	}
    /* As we've been creating subroutines, we better invalidate any cached
       methods  */
    mro_method_changed_in(symbol_table);
  }

#line 647 "B.xs"
{
    CV *cv;
    const char *file = __FILE__;
    MY_CXT_INIT;
    specialsv_list[0] = Nullsv;
    specialsv_list[1] = &PL_sv_undef;
    specialsv_list[2] = &PL_sv_yes;
    specialsv_list[3] = &PL_sv_no;
    specialsv_list[4] = (SV *) pWARN_ALL;
    specialsv_list[5] = (SV *) pWARN_NONE;
    specialsv_list[6] = (SV *) pWARN_STD;

    cv = newXS("B::init_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, initav);
    cv = newXS("B::check_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, checkav_save);
#if PERL_VERSION >= 9
    cv = newXS("B::unitcheck_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, unitcheckav_save);
#endif
    cv = newXS("B::begin_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, beginav_save);
    cv = newXS("B::end_av", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, endav);
    cv = newXS("B::main_cv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, main_cv);
    cv = newXS("B::inc_gv", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, incgv);
    cv = newXS("B::defstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, defstash);
    cv = newXS("B::curstash", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, curstash);
    cv = newXS("B::formfeed", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, formfeed);
#ifdef USE_ITHREADS
    cv = newXS("B::regex_padav", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, regex_padav);
#endif
    cv = newXS("B::warnhook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, warnhook);
    cv = newXS("B::diehook", intrpvar_sv_common, file);
    ASSIGN_COMMON_ALIAS(I, diehook);
}

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#line 1161 "B.xs"
{
	CV *cv;
#ifdef USE_ITHREADS
        cv = newXS("B::PMOP::pmoffset", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = PMOP_pmoffset_ix;
        cv = newXS("B::COP::stashpv", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_stashpv_ix;
        cv = newXS("B::COP::file", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_file_ix;
#else
        cv = newXS("B::COP::stash", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_stash_ix;
        cv = newXS("B::COP::filegv", XS_B__OP_next, __FILE__);
        XSANY.any_i32 = COP_filegv_ix;
#endif
#if PERL_VERSION >= 9
        cv = newXS("B::PMOP::reflags", XS_B__PMOP_precomp, __FILE__);
        XSANY.any_i32 = 1;
#endif
}

#if XSubPPtmpAAAH
#if XSubPPtmpAAAI
#endif
#endif
#if XSubPPtmpAAAJ
#endif
#if XSubPPtmpAAAK
#endif
#if XSubPPtmpAAAL
#endif
#if XSubPPtmpAAAM
#endif
#if XSubPPtmpAAAN
#endif
#if XSubPPtmpAAAO
#endif
#if XSubPPtmpAAAP
#endif
#if XSubPPtmpAAAQ
#endif
#line 4187 "B.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

